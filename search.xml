<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MySQL表字段设计原则</title>
    <url>/2020/08/17/Mysql%E8%A1%A8%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>一般重要的字段为类型，长度，属性，非空，索引，自增等等。</p>
<p> 数据表在进行表字段的设计的时候需要根据业务实际出发，根据字段特性设计合适的字段类型和索引类型、长度和属性等。</p>
<p>字段的类型有多种，先说下字段中比较常用的类型和长度：</p>
<a id="more"></a>


<h2 id="整数型"><a href="#整数型" class="headerlink" title="整数型"></a>整数型</h2><pre><code>1、整数型的数值类型已经限制了取值范围，有符号整型和无符号整型都有，而M值并不代表可以存储的数值字符长度，它代表的是数据在显示时显示的最小长度；

2、当存储的字符长度超过M值时，没有任何的影响，只要不超过数值类型限制的范围；

3、当存储的字符长度小于M值时，只有在设置了zerofill用0来填充，才能够看到效果，换句话就是说，没有zerofill，M值就是无用的。</code></pre><p>举例子，如果你设置int(11)，那么有个字段值是123，那么这个值在显示宽度上是3位，而设计的是显示的是11位，所以这时候，你如果在字段设计的时候，选择zerofill就可以发现，123变成了00000000123，也就是剩下的8位用0补足了。</p>
<p>所以我们在设计mysql数据库时，建表时，mysql会自动分配长度：int(11)、tinyint(4)、smallint(6)、mediumint(9)、bigint(20)。</p>
<p>所以，就用这些默认的显示长度就可以了。不用再去自己填长度，比如搞个int(10)、tinyint(1)之类的，基本没用。而且导致表的字段类型多样化。</p>
<h2 id="字符串型"><a href="#字符串型" class="headerlink" title="字符串型"></a>字符串型</h2><p><strong>CHAR(M)</strong> , <strong>VARCHAR(M)</strong></p>
<p>CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间，当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。CHAR存储定长数据很方便，CHAR字段上的索引效率级高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。</p>
<p>VARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间，(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。varchar存储变长数据，但存储效率没有CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。</p>
<p>CHAR和VARCHAR最大的不同就是一个是固定长度，一个是可变长度。</p>
<p>总结一下，从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点，所有当需要大量查询需求的时候，用char。当对于保存数据量过大的需求时，为了节省储存空间用varchar。</p>
<p><strong>TEXT</strong></p>
<p>最大长度为65,535(2的16次方–1)字符的TEXT列。</p>
<p>Text主要是用来存放非二进制的文本，如论坛帖子,题目，或者百度知道的问题和回答之类。TEXT列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。其实可以总结为用来储存大批量的文本信息的时候，使用TEXT。</p>
<pre><code>**总结**
1，长度的区别，char范围是0～255，varchar最长是64k，如果遇到了大文本，考虑使用text，最大能到4G。
2，效率来说基本是char&gt;varchar&gt;text。
3，char和varchar可以有默认值，text不能指定默认值。</code></pre><h2 id="时间型"><a href="#时间型" class="headerlink" title="时间型"></a>时间型</h2><p><strong>DATETIME</strong>类型用在你需要同时包含日期和时间信息的值时。MySQL检索并且以’YYYY-MM-DD HH:MM:SS’格式显示DATETIME值，支持的范围<br>是’1000-01-01 00:00:00’到’9999-12-31 23:59:59’。</p>
<p><strong>DATE</strong>类型用在你仅需要日期值时，没有时间部分。MySQL检索并且以’YYYY-MM-DD’格式显示DATE值，支持的范围是’1000-01-01’到’9999-12-31’。</p>
<p><strong>TIMESTAMP</strong>列类型提供一种类型，你可以使用它自动地用当前的日期和时间标记INSERT或UPDATE的操作。</p>
<p><strong>TIME</strong>数据类型表示一天中的时间。MySQL检索并且以”HH:MM:SS”格式显示TIME值。支持的范围是’00:00:00’到’23:59:59’。</p>
<pre><code>datetime和timestamp的区别：

1.datetime 的日期范围比较大；如果有1970年以前的数据还是要用datetime.但是timestamp 所占存储空间比较小。
2.timestamp 类型的列还有个特性：默认情况下，在 insert, update 数据时，timestamp 列会自动以当前时间（CURRENT_TIMESTAMP）填充/更新。
3.timestamp比较受时区timezone的影响以及MYSQL版本和服务器的SQL MODE的影响。</code></pre><h2 id="字段的属性值及用处"><a href="#字段的属性值及用处" class="headerlink" title="字段的属性值及用处"></a>字段的属性值及用处</h2><p><strong>BINARY</strong>：不是函数，是类型转换运算符，它用来强制它后面的字符串为一个二进制字符串，可以理解为在字符串比较的时候区分大小写。</p>
<p><strong>UNSIGNED</strong>：既为非负数，用此类型可以增加一倍数据长度!</p>
<img src="/2020/08/17/Mysql%E8%A1%A8%E5%AD%97%E6%AE%B5%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/image1.png" class="" title="This is an unsigned image">


<p><strong>ZEROFILL</strong>:刚说过了，数字型字段当存储的字符长度小于INT(M)中的M值时，只有在设置了zerofill用0来填充，才能够看到效果，换句话就是说，没有zerofill，M值就是无用的。</p>
<p><strong>timestamp</strong>有两个属性，分别是<strong>CURRENT_TIMESTAMP</strong> 和 <strong>ON UPDATE CURRENT_TIMESTAMP</strong> 两种，使用情况分别如下</p>
<p>1，CURRENT_TIMESTAMP </p>
<p>当要向数据库执行insert操作时，如果有个timestamp字段属性设为CURRENT_TIMESTAMP，则无论这个字段有没有set值都插入当前系统时间</p>
<p>2，ON UPDATE CURRENT_TIMESTAMP</p>
<p>当执行update操作是，并且字段有ON UPDATE CURRENT_TIMESTAMP属性。则字段无论值有没有变化，它的值也会跟着更新为当前UPDATE操作时的时间。</p>
<h2 id="字段的索引以及设置"><a href="#字段的索引以及设置" class="headerlink" title="字段的索引以及设置"></a>字段的索引以及设置</h2><p>先说下对索引的最简单的理解：</p>
<p>如果你给一个唯一性的字段加上索引，比如一个字段是房间号，你不设置字段的情况下去搜索RoomNumber=101，那么数据库会去一条一条的搜索数据库中的RoomNumber字段，直到找到101给你返回，但如果你把RoomNumber设置为索引，那么数据库就会直接找到RoomNumber=101这条信息给你返回。所以索引的作用是加快数据库搜索的效率，但是同样的，你给一个字段设置为索引，是要消耗资源的。</p>
<pre><code>普通索引(**INDEX**)：最基本的索引，没有任何限制。

唯一索引(**UNIQUE**)：与&quot;普通索引&quot;类似，不同的就是：索引列的值必须唯一，但允许有空值。

主键索引(**PRIMARY**)：它 是一种特殊的唯一索引，不允许有空值。

全文索引(**FULLTEXT**)：仅可用于 MyISAM 表， 用于在一篇文章中，检索文本信息的, 针对较大的数据，生成全文索引很耗时耗空间。</code></pre><p>说一下字段的长度问题<br>位（bit）：数据存储的最小单位。每个二进制数字0或者1就是1个位；</p>
<p>字节（byte）： 8个位构成一个字节；即：1 byte (字节)= 8 bit(位)；</p>
<p>字符：是指计算机中使用的字母、数字、字和符号。</p>
<p>比如不同的酒店的房间号的方式是不同的，可能是101，或者是FD101，再或者是亚特兰蒂斯101，这样不确定的字段，为了提高表的复用性，我们可以给出一个长度，比如char(32)，我们可以确定酒店的房间号无论如何都会超过这个长度，这样就可以在节省空间的情况下适应所有的情况，</p>
<p>但是还有一种情况比如数据库中要存MAC地址，MAC地址格式为XX-XX-XX-XX-XX-XX，一共为12个数字和五个分隔符，那么我们就可以直接char(17)来定死这个字段的长度，因为无论如何MAC地址都不会超过17位。</p>
<p>其实也会有人觉得我定为char(32)那能比char(17)的查询效率低多少？确实微乎其微，但是从习惯的角度来说，建表要养成一种好的习惯，所以当我们可以确定一个字段的长度的时候，就要直接用规则定死，避免掉后期可能出现的优化。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一次线上Redis宕机</title>
    <url>/2020/08/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8ARedis%E5%AE%95%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="SlowLog说明"><a href="#SlowLog说明" class="headerlink" title="SlowLog说明"></a>SlowLog说明</h2><p>Slowlog 是 Redis用来记录查询执行时间的日志系统。注意，这个查询执行时间指的是不包括像客户端响应(talking)、发送回复等IO操作，而单单是执行一个查询命令所耗费的时间。</p>
<a id="more"></a>
<img src="/2020/08/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8ARedis%E5%AE%95%E6%9C%BA/image.png" class="" title="This is an example image">

<p>slowlog 保存在内存里面，读写速度非常快，因此我们可以放心地使用它，不必担心因为开启slowlog 而损害 Redis 的速度。</p>
<p>slowlog 有两个重要的配置，我们先通过 CONFIG GET slowlog-* 命令来查看现有的配置。<br><code>127.0.0.1:6379&gt; CONFIG GET slowlog-*</code></p>
<ol>
<li><p>“slowlog-log-slower-than”</p>
</li>
<li><p>“100”</p>
</li>
<li><p>“slowlog-max-len”</p>
</li>
<li><p>“1024”</p>
</li>
</ol>
<p>slowlog-log-slower-than代表慢查询的阈值，单位为：微秒。当执行查询命令消耗时间大于配置的阈值时，会将该条命令记录到慢查询日志。<br>当slowlog-log-slower-than=0时，记录所有命令。slowlog-log-slower-than&lt;0时，不记录任何命令。<br>slowlog-log-slower-than 的默认值为 10000 （10毫秒，1秒 =1,000毫秒 = 1,000,000微秒）。</p>
<p>slowlog-max-len<br>代表慢查询日志最大条数。它是一个队列形式的存储结构，先进先出的队列，即当慢查询日志达到最大条数后，会销毁最早记录的日志条目。slowlog-max-len的默认值为 128，保存在内存内，所以重启 redis 会清空慢查询日志。</p>
<p>配置 <em>slowlog-log-slower-than</em> 和 <em>slowlog-max-len</em> 的命令非常简单，如下：</p>
<ol>
<li><p><code>CONFIG SET slowlog-log-slower-than 100</code></p>
</li>
<li><p><code>CONFIG SET slowlog-max-len 1024</code></p>
</li>
</ol>
<p>使用 SLOWLOG LEN 命令，查询当前的慢查询日志记录数。</p>
<pre><code>1. 127.0.0.1:6379&gt; `SLOWLOG LEN`

2. (integer) 2019</code></pre><p>当我们只需要查询前几个慢查询记录时，可以使用 SLOWLOG GET <code>[n]</code> 命令。</p>
<pre><code>127.0.0.1:6379&gt; SLOWLOG GET 3

1)  
     1. (integer) 14         # 唯一性(unique)的日志标识符

     2. (integer) 1522808219 # 被记录命令的执行时间点，以 UNIX 时间戳格式表示

     3. (integer) 16         # 查询执行时间，以微秒为单位

     4. &quot;keys&quot;               # 执行的命令，以数组的形式排列

     5. &quot;*&quot;                  # 这里完整的命令是 &quot;keys *&quot;

2)  
     (integer) 13

     (integer) 1522808215

     (integer) 7

      a. &quot;set&quot;

      b. &quot;name&quot;

      c. &quot;baicai&quot;


3)  
      1) (integer) 12

      2) (integer) 1522808198

      3) (integer) 101

4)   
      1) &quot;set&quot;

      2) &quot;age&quot;

      3) &quot;25&quot;</code></pre><p>SLOWLOG GET <code>[n]</code> 若不加 n ,则获取全部慢查询记录。</p>
<p>清空慢查询日志使用 SLOWLOG RESET。注意，slowlog-log-slower-than<br>不要设置过大，设置过大有可能一条记录也不会记录。</p>
<h2 id="线上实际业务需求："><a href="#线上实际业务需求：" class="headerlink" title="线上实际业务需求："></a>线上实际业务需求：</h2><p>车辆从龙门架经过，被抓拍机抓拍车牌数据后推送到分流LED屏幕，根据车道管理配置规则分配分流车道号，该数据存放在redis缓存中，时效5分钟；<br>到安检车道安检后删除缓存中对应车辆数据。</p>
<img src="/2020/08/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8ARedis%E5%AE%95%E6%9C%BA/image_3.png" class="" title="This is an example image">

<p>该业务在车流量大时频繁读写相关key，因此在存放消息队列的方法内在进行redis读写操作时，为防止消息队列的数据隔离安全问题加了ReenTranLock，<br>但内部方法又涉及了其他的业务操作，并且其他的业务操作也去读取了redis相关数据；所以尽可能不涉及再操作其他的业务流程操作和方法体内再读写其他相关redis业务数据；<br>否则，可能造成redis慢查询；而在锁未释放时，线上其他业务也访问redis，redis连接池慢查询未释放资源，导致最终服务宕机不可用。</p>
<img src="/2020/08/11/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8ARedis%E5%AE%95%E6%9C%BA/image_1.png" class="" title="This is an example image">


<p><strong>解决方式：</strong><br>    将相关业务代码抽离出来；ReidsQunene只进行单一的读写业务操作；</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
        <category>线上</category>
      </categories>
      <tags>
        <tag>线上生产记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis笔记</title>
    <url>/2020/08/18/Redis%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Redis简介"><a href="#1-Redis简介" class="headerlink" title="1.Redis简介"></a>1.Redis简介</h2><p>Redis 是我们在互联网应用中使用最广泛的一个 NoSQL 数据库，基于 C 开发的键值对存储数据库，<br>Redis 这个名字是 Remote Dictionary Service 字母缩写。<br>很多人想到 Redis，就想到缓存。但实际上 Redis 除了缓存之外，还有许多更加丰富的使用场景。比如<br>分布式锁，限流。</p>
<a id="more"></a>

<p>特点:</p>
<ul>
<li>支持数据持久化</li>
<li>支持多种不同的数据结构类型之间的映射</li>
<li>支持主从模式的数据备份</li>
<li>自带了发布订阅系统</li>
<li>定时器、计数器</li>
</ul>
<h2 id="2-Redis安装"><a href="#2-Redis安装" class="headerlink" title="2.Redis安装"></a>2.Redis安装</h2><p>四种方式获取一个 Redis：</p>
<ul>
<li><ol>
<li>直接编译安装（推荐使用）</li>
</ol>
</li>
<li><ol start="2">
<li>使用 Docker</li>
</ol>
</li>
<li><ol start="3">
<li>也可以直接安装</li>
</ol>
</li>
<li><ol start="4">
<li>还有一个在线体验的方式，通过在线体验，可以直接使用 Redis 的功能 <a href="http://try.redis.io" target="_blank" rel="noopener">http://try.redis.io</a></li>
</ol>
</li>
</ul>
<h3 id="2-1-直接安装编译"><a href="#2-1-直接安装编译" class="headerlink" title="2.1 直接安装编译"></a>2.1 直接安装编译</h3><p>准备gcc环境</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>
<p>下载并安装redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.7.tar.gz</span><br><span class="line">tar -zxvf redis-5.0.7.tar.gz</span><br><span class="line">cd redis-5.0.7&#x2F;</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>安装完成，启动redis</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure>
<img src="/2020/08/18/Redis%E7%AC%94%E8%AE%B0/1.png" class="" title="This is an example image">

<h3 id="2-2-通过-Docker-安装"><a href="#2-2-通过-Docker-安装" class="headerlink" title="2.2 通过 Docker 安装"></a>2.2 通过 Docker 安装</h3><p>Docker 安装好之后，启动 Docker ，直接运行安装命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name wangts-redis -d -p 6379:6379 redis --requirepass 123</span><br></pre></td></tr></table></figure>
<p>Docker 上的 Redis 启动成功之后，可以从宿主机上连接（前提是宿主机上存在 redis-cli）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli -a 123</span><br></pre></td></tr></table></figure>
<p>如果宿主机上没有安装 Redis，那么也可以进入到 Docker 容器种去操作 Redis:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it wangts-redis redis-cli -a 123</span><br></pre></td></tr></table></figure>

<h3 id="2-3-直接安装"><a href="#2-3-直接安装" class="headerlink" title="2.3 直接安装"></a>2.3 直接安装</h3><p>CENTOS:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install redis</span><br></pre></td></tr></table></figure>

<p>Ubuntu:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install redis</span><br></pre></td></tr></table></figure>

<p>Mac:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure>

<h2 id="3-Redis-五种基本数据类型"><a href="#3-Redis-五种基本数据类型" class="headerlink" title="3. Redis 五种基本数据类型"></a>3. Redis 五种基本数据类型</h2><h3 id="3-1-Reids启动"><a href="#3-1-Reids启动" class="headerlink" title="3.1 Reids启动"></a>3.1 Reids启动</h3><p>首先，修改 redis.conf 配置文件：</p>
<img src="/2020/08/18/Redis%E7%AC%94%E8%AE%B0/2.png" class="" title="This is an example image">
<p>配置完成后，保存退出，再次通过 redis-server redis.conf 命令启动 Redis，此时，就是在后台启<br>动了。</p>
<img src="/2020/08/18/Redis%E7%AC%94%E8%AE%B0/3.png" class="" title="This is an example image">
<h3 id="3-2-String"><a href="#3-2-String" class="headerlink" title="3.2 String"></a>3.2 String</h3><p>String 是 Redis 里边最最简单的一种数据结构。在 Redis 中，所以的 key 都是字符串，但是，不同的<br>key 对应的 value 则具备不同的数据结构，我们所说的五种不同的数据类型，主要是指 value 的数据类<br>型不同。</p>
<p>Redis 中的字符串是动态字符串，内部是可以修改的，像 Java 中的 StringBuffer，它采用分配冗余空间<br>的方式来减少内存的频繁分配。在 Redis 内部结构中，一般实际分配的内存会大于需要的内存，当字符<br>串小于 1M 的时候，扩容都是在现有的空间基础上加倍，扩容每次扩 1M 空间，最大 512M。</p>
<ul>
<li>set<br>set 就是给一个 key 赋值的。</li>
<li>append<br>使用 append 命令时，如果 key 已经存在，则直接在对应的 value 后追加值，否则就创建新的键值对。</li>
<li>decr<br>可以实现对 value 的减 1 操作（前提是 value 是一个数字），如果 value 不是数字，会报错，如果<br>value 不存在，则会给一个默认的值为 0，在默认值的基础上减一。</li>
<li>decrby<br>和 decr 类似，但是可以自己设置步长，该命令第二个参数就是步长。</li>
<li>get<br>get 用来获取一个 key 的 value。</li>
<li>getrange<br>getrange 可以用来返回 key 对应的 value 的子串，这有点类似于 Java 里边的 substring。这个命令第<br>二个和第三个参数就是截取的起始和终止位置，其中，-1 表示最后一个字符串，-2 表示倒数第二个字符<br>串，以此类推…</li>
<li>getset<br>获取并更新某一个 key。</li>
<li>incr<br>给某一个 key 的 value 自增。</li>
<li>incrby<br>给某一个 key 的 value 自增，同时还可以设置步长。</li>
<li>incrbyfloat<br>和 incrby 类似，但是自增的步长可以设置为浮点数。</li>
<li>mget 和 mset<br>批量获取和批量存储</li>
<li>ttl<br>查看 key 的有效期</li>
<li>setex<br>在给 key 设置 value 的同时，还设置过期时间。</li>
<li>psetex<br>和 setex 类似，只不过这里的时间单位是毫秒。</li>
<li>setnx<br>默认情况下， set 命令会覆盖已经存在的 key，setnx 则不会。</li>
<li>msetnx<br>批量设置。</li>
<li>setrange<br>覆盖一个已经存在的 key 的value。</li>
<li>strlen<br>查看字符串长度</li>
</ul>
<h3 id="3-2-1"><a href="#3-2-1" class="headerlink" title="3.2.1"></a>3.2.1</h3><p>BIT命令<br>在 Redis 中，字符串都是以二进制的方式来存储的。例如 set k1 a，a 对应的 ASCII 码是 97，97 转为<br>二进制是 01100001，BIT 相关的命令就是对二进制进行操作的。</p>
<ul>
<li>getbit<br>key 对应的 value 在 offset 处的 bit 值。</li>
<li>setbit<br>修改 key 对应的 value 在 offset 处的 bit 值</li>
<li>bitcount<br>统计二进制数据中 1 的个数</li>
</ul>
<h3 id="3-3-List"><a href="#3-3-List" class="headerlink" title="3.3 List"></a>3.3 List</h3><ul>
<li>lpush<br>将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个<br>空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。</li>
<li>lrange<br>返回列表指定区间内的元素。</li>
<li>rpush<br>向存于 key 的列表的尾部插入所有指定的值。</li>
<li>rpop<br>移除并返回列表的尾元素。</li>
<li>lpop<br>移除并返回列表的头元素。</li>
<li>lindex<br>返回列表中，下标为 index 的元素。</li>
<li>ltrim<br>ltrim 可以对一个列表进行修剪。</li>
<li>blpop<br>阻塞式的弹出，相当于 lpop 的阻塞版</li>
</ul>
<h3 id="3-4-Set"><a href="#3-4-Set" class="headerlink" title="3.4 Set"></a>3.4 Set</h3><ul>
<li>sadd<br>添加元素到一个 key 中</li>
<li>smembers<br>获取一个 key 下的所有元素</li>
<li>srem<br>移除指定的元素</li>
<li>sismemeber<br>返回某一个成员是否在集合中</li>
<li>scard<br>返回集合的数量</li>
<li>srandmember<br>随机返回一个元素</li>
<li>spop<br>随机返回并且出栈一个元素。</li>
<li>smove<br>把一个元素从一个集合移到另一个集合中去。</li>
<li>sdiff<br>返回两个集合的差集。</li>
<li>sinter<br>返回两个集合的交集。</li>
<li>sdiffstore<br>这个类似于 sdiff ，不同的是，计算出来的结果会保存在一个新的集合中。</li>
<li>sinterstore<br>类似于 sinter，只是将计算出来的交集保存到一个新的集合中。</li>
<li>sunion<br>求并集。</li>
<li>sunionstore<br>求并集并且将结果保存到新的集合中。</li>
</ul>
<h3 id="3-5-Hash"><a href="#3-5-Hash" class="headerlink" title="3.5 Hash"></a>3.5 Hash</h3><p>在 hash 结构中，key 是一个字符串，value 则是一个 key/value 键值对。</p>
<ul>
<li>hset<br>添加值。</li>
<li>hget<br>获取值</li>
<li>hmset<br>批量设置</li>
<li>hmget<br>批量获取</li>
<li>hdel<br>删除一个指定的 field</li>
<li>hsetnx<br>默认情况下，如果 key 和 field 相同，会覆盖掉已有的 value，hsetnx 则不会。</li>
<li>hvals<br>获取所有的 value</li>
<li>hkeys<br>获取所有的 key</li>
<li>hgetall<br>同时获取所有的 key 和 value</li>
<li>hexists<br>返回 field 是否存在</li>
<li>hincrby<br>给指定的 value 自增</li>
<li>hincrbyfloat<br>可以自增一个浮点数</li>
<li>hlen<br>返回 某一个 key 中 value 的数量</li>
<li>hstrlen<br>返回某一个 key 中的某一个 field 的字符串长度</li>
</ul>
<h3 id="3-6-Zset"><a href="#3-6-Zset" class="headerlink" title="3.6 Zset"></a>3.6 Zset</h3><ul>
<li>zadd<br>将指定的元素添加到有序集合中。</li>
<li>zscore<br>返回 member 的 score 值</li>
<li>zrange<br>返回集合中的一组元素。</li>
<li>zrevrange<br>返回一组元素，但是是倒序。</li>
<li>zcard<br>返回元素个数</li>
<li>zcount<br>返回 score 在某一个区间内的元素。</li>
<li>zrangebyscore<br>按照 score 的范围返回元素。</li>
<li>zrank<br>返回元素的排名（从小到大</li>
<li>zrevrank<br>返回元素排名（从大到小</li>
<li>zincrbyscore<br>自增</li>
<li>zinterstore<br>给两个集合求交集。</li>
<li>zrem<br>弹出一个元素</li>
<li>zlexcount<br>计算有序集合中成员数量</li>
<li>zrangebylex<br>返回指定区间内的成员。<h3 id="3-7-key"><a href="#3-7-key" class="headerlink" title="3.7 key"></a>3.7 key</h3></li>
<li>del<br>删除一个 key/value</li>
<li>dump<br>序列化给定的 key</li>
<li>exists<br>判断一个 key 是否存在</li>
<li>ttl<br>查看一个 key 的有效期</li>
<li>expire<br>给一个 key 设置有效期，如果 key 在过期之前被重新 set 了，则过期时间会失效。</li>
<li>persist<br>移除一个 key 的过期时间</li>
<li>keys *<br>查看所有的 key</li>
<li>pttl<br>和 ttl 一样，只不过这里返回的是毫秒</li>
</ul>
<h2 id="4-Redis-的-Java-客户端"><a href="#4-Redis-的-Java-客户端" class="headerlink" title="4 Redis 的 Java 客户端"></a>4 Redis 的 Java 客户端</h2><h3 id="4-1-开启远程连接"><a href="#4-1-开启远程连接" class="headerlink" title="4.1 开启远程连接"></a>4.1 开启远程连接</h3><p>Redis 默认是不支持远程连接的，需要手动开启。<br>一共修改两个地方：</p>
<ol>
<li>注释掉 bind: 127.0.0.1</li>
<li>开启密码校验，去掉 requirepass 的注释<br>改完之后，保存退出，启动 Redis</li>
</ol>
<h3 id="4-2-Jedis"><a href="#4-2-Jedis" class="headerlink" title="4.2 Jedis"></a>4.2 Jedis</h3><h4 id="4-2-1-基本使用"><a href="#4-2-1-基本使用" class="headerlink" title="4.2.1 基本使用"></a>4.2.1 基本使用</h4><p>Jedis 的 GitHub 地址：<a href="https://github.com/xetorthio/jedis" target="_blank">https://github.com/xetorthio/jedis</a><br>首先创建一个普通的 Maven 项目。<br>项目创建成功后，添加Jedis 依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.2.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;type&gt;jar&lt;&#x2F;type&gt;</span><br><span class="line">    &lt;scope&gt;compile&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>然后创建一个测试方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.构造一个 Jedis 对象，因为这里使用的默认端口 6379，所以不用配置端口</span></span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"192.168.91.128"</span>);</span><br><span class="line">        <span class="comment">//2.密码认证</span></span><br><span class="line">        jedis.auth(<span class="string">"wangts"</span>);</span><br><span class="line">        <span class="comment">//3.测试是否连接成功</span></span><br><span class="line">        String ping = jedis.ping();</span><br><span class="line">        <span class="comment">//4.返回 pong 表示连接成功</span></span><br><span class="line">        System.out.println(ping);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 Jedis 而言，一旦连接上 Redis 服务端，剩下的操作都很容易了。<br>在 Jedis 中，由于方法的 API 和 Redis 的命令高度一致，所以，Jedis 中的方法见名知意，直接使用即<br>可。</p>
<h4 id="4-2-2-连接池"><a href="#4-2-2-连接池" class="headerlink" title="4.2.2 连接池"></a>4.2.2 连接池</h4><p>在实际应用中，Jedis 实例我们一般都是通过连接池来获取，由于 Jedis 对象不是线程安全的，所以，当<br>我们使用 Jedis 对象时，从连接池获取 Jedis，使用完成之后，再还给连接池。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 构造一个 Jedis 连接池</span></span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.91.128"</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2. 从连接池中获取一个 Jedis 连接</span></span><br><span class="line">        Jedis jedis = pool.getResource();</span><br><span class="line">        <span class="comment">//3. Jedis 操作</span></span><br><span class="line">        String ping = jedis.ping();</span><br><span class="line">        System.out.println(ping);</span><br><span class="line">        <span class="comment">//4. 归还连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果第三步抛出异常的话，会导致第四步无法执行，所以，我们要对代码进行改进，确保第四步能够执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//1. 构造一个 Jedis 连接池</span></span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.91.128"</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//2. 从连接池中获取一个 Jedis 连接</span></span><br><span class="line">        jedis = pool.getResource();</span><br><span class="line">        jedis.auth(<span class="string">"wangts"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//3. Jedis 操作</span></span><br><span class="line">            String ping = jedis.ping();</span><br><span class="line">            System.out.println(ping);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4. 归还连接</span></span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过 finally 我们可以确保 jedis 一定被关闭。<br>利用 JDK1.7 中的 try-with-resource 特性，可以对上面的代码进行改造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JedisPool pool = <span class="keyword">new</span> JedisPool(<span class="string">"192.168.91.128"</span>);</span><br><span class="line">        <span class="keyword">try</span>(Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">            jedis.auth(<span class="string">"wangts"</span>);</span><br><span class="line">            String ping = jedis.ping();</span><br><span class="line">            System.out.println(ping);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这段代码的作用和上面的是一致的。<br>但是，上面这段代码无法实现强约束。我们可以做进一步的改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallWithJedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Jedis jedis)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Redis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JedisPool pool;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Redis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GenericObjectPoolConfig config = <span class="keyword">new</span> GenericObjectPoolConfig();</span><br><span class="line">        <span class="comment">//连接池最大空闲数</span></span><br><span class="line">        config.setMaxIdle(<span class="number">300</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        config.setMaxTotal(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//连接最大等待时间，如果是 -1 表示没有限制</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">30000</span>);</span><br><span class="line">        <span class="comment">//在空闲时检查有效性</span></span><br><span class="line">        config.setTestOnBorrow(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1. Redis 地址</span></span><br><span class="line"><span class="comment">         * 2. Redis 端口</span></span><br><span class="line"><span class="comment">         * 3. 连接超时时间</span></span><br><span class="line"><span class="comment">		 * 4. 密码</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        pool = <span class="keyword">new</span> JedisPool(config, <span class="string">"192.168.91.128"</span>, <span class="number">6379</span>, <span class="number">30000</span>, <span class="string">"wangts"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CallWithJedis callWithJedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Jedis jedis = pool.getResource()) &#123;</span><br><span class="line">            callWithJedis.call(jedis);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">redis.execute(jedis -&gt; &#123;</span><br><span class="line">    System.out.println(jedis.ping());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="4-3-Lettuce"><a href="#4-3-Lettuce" class="headerlink" title="4.3 Lettuce"></a>4.3 Lettuce</h3><p>GitHub：<a target="_blank" href="https://github.com/lettuce-io/lettuce-core">https://github.com/lettuce-io/lettuce-core</a><br>Lettuce 和 Jedis 的一个比较：</p>
<blockquote>
<ol>
<li>Jedis 在实现的过程中是直接连接 Redis 的，在多个线程之间共享一个 Jedis 实例，这是线程不安全的，<br>如果想在多线程场景下使用 Jedis，就得使用连接池，这样，每个线程都有自己的 Jedis 实例。</li>
<li>Lettuce 基于目前很火的 Netty NIO 框架来构建，所以克服了 Jedis 中线程不安全的问题，Lettuce<br>支持同步、异步 以及 响应式调用，多个线程可以共享一个连接实例。<br>使用 Lettuce，首先创建一个普通的 Maven 项目，添加 Lettuce 依赖:</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.lettuce&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lettuce-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
<p>然后来一个简单的测试案例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LettuceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RedisClient redisClient = RedisClient.create(<span class="string">"redis://wangts@192.168.91.128"</span>);</span><br><span class="line">        StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect();</span><br><span class="line">        RedisCommands&lt;String, String&gt; sync = connect.sync();</span><br><span class="line">        sync.set(<span class="string">"name"</span>, <span class="string">"wangts"</span>);</span><br><span class="line">        String name = sync.get(<span class="string">"name"</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这里的密码传递方式，密码直接写在连接地址里边。</p>
<h2 id="5-Redis-做分布式锁"><a href="#5-Redis-做分布式锁" class="headerlink" title="5 Redis 做分布式锁"></a>5 Redis 做分布式锁</h2><p>问题场景：</p>
<blockquote>
<blockquote>
<p>例如一个简单的用户操作，一个线程去修改用户的状态，首先从数据库中读出用户的状态，然后<br>在内存中进行修改，修改完成后，再存回去。在单线程中，这个操作没有问题，但是在多线程<br>中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题。<br>对于这种问题，我们可以使用分布式锁来限制程序的并发执行。</p>
</blockquote>
</blockquote>
<h3 id="5-1-基本用法"><a href="#5-1-基本用法" class="headerlink" title="5.1 基本用法"></a>5.1 基本用法</h3><p><strong>分布式锁实现的思路很简单，就是进来一个线程先占位，当别的线程进来操作时，发现已经有人占位了，就会放弃或者稍后再试。</strong></p>
<p>在 Redis 中，占位一般使用 setnx 指令，先进来的线程先占位，线程的操作执行完成后，再调用 del 指令释放位子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis-&gt;&#123;</span><br><span class="line">            Long setnx = jedis.setnx(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">            <span class="keyword">if</span> (setnx == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//没人占位</span></span><br><span class="line">                jedis.set(<span class="string">"name"</span>, <span class="string">"wangts"</span>);</span><br><span class="line">                String name = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                jedis.del(<span class="string">"k1"</span>);<span class="comment">//释放资源</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有人占位，停止/暂缓 操作</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码存在一个小小问题：如果代码业务执行的过程中抛异常或者挂了，这样会导致 del 指令没有<br>被调用，这样，k1 无法释放，后面来的请求全部堵塞在这里，锁也永远得不到释放。</p>
<p>要解决这个问题，我们可以给锁添加一个过期时间，确保锁在一定的时间之后，能够得到释放。改进后<br>的代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">       redis.execute(jedis-&gt;&#123;</span><br><span class="line">           Long setnx = jedis.setnx(<span class="string">"k1"</span>, <span class="string">"v1"</span>);</span><br><span class="line">           <span class="keyword">if</span> (setnx == <span class="number">1</span>) &#123;</span><br><span class="line">               <span class="comment">//给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放</span></span><br><span class="line">               jedis.expire(<span class="string">"k1"</span>, <span class="number">5</span>);</span><br><span class="line">               <span class="comment">//没人占位</span></span><br><span class="line">               jedis.set(<span class="string">"name"</span>, <span class="string">"wangts"</span>);</span><br><span class="line">               String name = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">               System.out.println(name);</span><br><span class="line">               jedis.del(<span class="string">"k1"</span>);<span class="comment">//释放资源</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			                <span class="comment">//有人占位，停止/暂缓 操作</span></span><br><span class="line">			   &#125;</span><br><span class="line">		   &#125;);</span><br><span class="line">	   &#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>这样改造之后，还有一个问题，就是在获取锁和设置过期时间之间如果如果服务器突然挂掉了，这个时<br>候锁被占用，无法及时得到释放，也会造成死锁，因为获取锁和设置过期时间是两个操作，不具备原子性。<br>为了解决这个问题，从 Redis2.8 开始，setnx 和 expire 可以通过一个命令一起来执行了，我们对上述<br>代码再做改进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">        redis.execute(jedis-&gt;&#123;</span><br><span class="line">            String set = jedis.set(<span class="string">"k1"</span>, <span class="string">"v1"</span>, <span class="keyword">new</span> SetParams().nx().ex(<span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span> (set !=<span class="keyword">null</span> &amp;&amp; <span class="string">"OK"</span>.equals(set)) &#123;</span><br><span class="line">                <span class="comment">//给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放</span></span><br><span class="line">                jedis.expire(<span class="string">"k1"</span>, <span class="number">5</span>);</span><br><span class="line">                <span class="comment">//没人占位</span></span><br><span class="line">                jedis.set(<span class="string">"name"</span>, <span class="string">"wangts"</span>);</span><br><span class="line">                String name = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">                System.out.println(name);</span><br><span class="line">                jedis.del(<span class="string">"k1"</span>);<span class="comment">//释放资源</span></span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//有人占位，停止/暂缓 操作</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-解决超时问题"><a href="#5-2-解决超时问题" class="headerlink" title="5.2 解决超时问题"></a>5.2 解决超时问题</h3><p>为了防止业务代码在执行的时候抛出异常，我们给每一个锁添加了一个超时时间，超时之后，锁会被自<br>动释放，但是这也带来了一个新的问题：如果要执行的业务非常耗时，可能会出现紊乱。举个例子：第<br>一个线程首先获取到锁，然后开始执行业务代码，但是业务代码比较耗时，执行了 8 秒，这样，会在第<br>一个线程的任务还未执行成功锁就会被释放了，此时第二个线程会获取到锁开始执行，在第二个线程刚<br>执行了 3 秒，第一个线程也执行完了，此时第一个线程会释放锁，但是注意，它释放的第二个线程的锁，<br>释放之后，第三个线程进来。<br>对于这个问题，我们可以从两个角度入手：</p>
<ul>
<li>尽量避免在获取锁之后，执行耗时操作。</li>
<li>可以在锁上面做文章，将锁的 value 设置为一个随机字符串，每次释放锁的时候，都去比较随机字符串是否一致，<br>如果一致，再去释放，否则，不释放。</li>
</ul>
<p>对于第二种方案，由于释放锁的时候，要去查看锁的 value，第二个比较 value 的值是否正确，第三步<br>释放锁，有三个步骤，很明显三个步骤不具备原子性，为了解决这个问题，我们得引入 Lua 脚本。<br>Lua 脚本的优势：</p>
<ul>
<li>使用方便，Redis 中内置了对 Lua 脚本的支持。</li>
<li>Lua 脚本可以在 Redis 服务端原子的执行多个 Redis 命令。</li>
<li>由于网络在很大程度上会影响到 Redis 性能，而使用 Lua 脚本可以让多个命令一次执行，可以有效解决网络给 Redis 带来的性能问题。</li>
</ul>
<p>在 Redis 中，使用 Lua 脚本，大致上两种思路：</p>
<ol>
<li>提前在 Redis 服务端写好 Lua 脚本，然后在 Java 客户端去调用脚本（推荐）。</li>
<li>可以直接在 Java 端去写 Lua 脚本，写好之后，需要执行时，每次将脚本发送到 Redis 上去执行。</li>
</ol>
<p>首先在 Redis 服务端创建 Lua 脚本，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;,KEYS[1])&#x3D;&#x3D;ARGV[1] then</span><br><span class="line">   return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">   return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>接下来，可以给 Lua 脚本求一个 SHA1 和，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat lua&#x2F;releasewherevalueequal.lua | redis-cli -a javaboy script load --pipe</span><br></pre></td></tr></table></figure>

<img src="/2020/08/18/Redis%E7%AC%94%E8%AE%B0/4.png" class="" title="This is an example image">

<p>script load 这个命令会在 Redis 服务器中缓存 Lua 脚本，并返回脚本内容的 SHA1 校验和，然后在<br>Java 端调用时，传入 SHA1 校验和作为参数，这样 Redis 服务端就知道执行哪个脚本了。<br>接下来，在 Java 端调用这个脚本。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LuaTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Redis redis = <span class="keyword">new</span> Redis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            redis.execute(jedis -&gt; &#123;</span><br><span class="line">                <span class="comment">//1.先获取一个随机字符串</span></span><br><span class="line">                String value = UUID.randomUUID().toString();</span><br><span class="line">                <span class="comment">//2.获取锁</span></span><br><span class="line">                String k1 = jedis.set(<span class="string">"k1"</span>, value, <span class="keyword">new</span> SetParams().nx().ex(<span class="number">5</span>));</span><br><span class="line">                <span class="comment">//3.判断是否成功拿到锁</span></span><br><span class="line">                <span class="keyword">if</span> (k1 != <span class="keyword">null</span> &amp;&amp; <span class="string">"OK"</span>.equals(k1)) &#123;</span><br><span class="line">                    <span class="comment">//4. 具体的业务操作</span></span><br><span class="line">                    jedis.set(<span class="string">"site"</span>, <span class="string">"www.wangts.site"</span>);</span><br><span class="line">                    String site = jedis.get(<span class="string">"site"</span>);</span><br><span class="line">                    System.out.println(site);</span><br><span class="line">                    <span class="comment">//5.释放锁</span></span><br><span class="line">                    jedis.evalsha(<span class="string">"b8059ba43af6ffe8bed3db65bac35d452f8115d8"</span>,</span><br><span class="line">Arrays.asList(<span class="string">"k1"</span>), Arrays.asList(value));</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"没拿到锁"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-Redis单线程如何处理高并发"><a href="#6-Redis单线程如何处理高并发" class="headerlink" title="6 Redis单线程如何处理高并发"></a>6 Redis单线程如何处理高并发</h2><h3 id="6-1-阻塞-IO-与非阻塞-IO"><a href="#6-1-阻塞-IO-与非阻塞-IO" class="headerlink" title="6.1 阻塞 IO 与非阻塞 IO"></a>6.1 阻塞 IO 与非阻塞 IO</h3><p>Java 在 JDK1.4 中引入 NIO，但是也有很多人在使用阻塞 IO，这两种 IO 有什么区别？<br>在阻塞模式下，如果你从数据流中读取不到指定大小的数据两，IO 就会阻塞。比如已知会有 10 个字节<br>发送过来，但是我目前只收到 4 个，还剩六个，此时就会发生阻塞。如果是非阻塞模式，虽然此时只收<br>到4 个字节，<br>但是读到 4 个字节就会立即返回，不会傻傻等着，等另外 6 个字节来的时候，再去继续读取。<br>所以阻塞 IO 性能低于 非阻塞 IO。<br>如果有一个 Web 服务器，使用阻塞 IO 来处理请求，那么每一个请求都需要开启一个新的线程；但是如<br>果使用了非阻塞 IO，基本上一个小小线程池就够用了，因为不会发生阻塞，每一个线程都能够高效利用。</p>
<h3 id="6-2-Redis-的线程模型"><a href="#6-2-Redis-的线程模型" class="headerlink" title="6.2 Redis 的线程模型"></a>6.2 Redis 的线程模型</h3><p>首先一点，Redis 是单线程。单线程如何解决高并发问题的？<br>实际上，能够处理高并发的单线程应用不仅仅是 Redis，除了 Redis 之外，还有 NodeJS、Nginx 等等<br>也是单线程。<br>Redis 虽然是单线程，但是运行很快，主要有如下几方面原因：</p>
<ol>
<li>Redis 中的所有数据都是基于内存的，所有的计算也都是内存级别的计算，所以快。</li>
<li>Redis 是单线程的，所以有一些时间复杂度高的指令，可能会导致 Redis 卡顿，例如 keys。</li>
<li>Redis 在处理并发的客户端连接时，使用了非阻塞 IO。<br>在使用非阻塞 IO 时，有一个问题，就是线程如何知道剩下的数据来了？<br>这里就涉及到一个新的概念叫做<strong>多路复用</strong>，本质上就是一个事件轮询 API。</li>
<li>Redis 会给每一个客户端指令通过队列来排队进行顺序处理。</li>
<li>Redis 做出响应时，也会有一个响应的队列。  </li>
</ol>
<h3 id="6-3-Redis-通信协议"><a href="#6-3-Redis-通信协议" class="headerlink" title="6.3 Redis 通信协议"></a>6.3 Redis 通信协议</h3><p>Redis 通信使用了文本协议，文本协议比较费流量，但是 Redis 作者认为数据库的瓶颈不在于网络流量，<br>而在于内部逻辑，所以采用了这样一个费流量的文本协议。<br>这个文本协议叫做 Redis Serialization Protocol，简称 RESP。<br>Redis 协议将传输的数据结构分为 5 种最小单元，单元结束时，加上回车换行符 \r\n。</p>
<ol>
<li>单行字符串以 + 开始，例如 +wangts.site\r\n</li>
<li>多行字符串以 $ 开始，后面加上字符串长度，例如 $11\r\nwangts.site\r\n</li>
<li>整数值以: 开始，例如 :1024\r\n</li>
<li>错误消息以 - 开始</li>
<li>数组以 * 开始，后面加上数组长度。<br>需要注意的是，如果是客户端连接服务端，只能使用第 5 种。</li>
</ol>
<p>接下来，我们通过 Socket+RESP 来定义两个最最常见的命令 set 和 get。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaboyRedisClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaboyRedisClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">"192.168.91.128"</span>, <span class="number">6379</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">"Redis 连接失败"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">/**</span></span><br><span class="line"><span class="comment">	     * 执行 Redis 中的 set 命令 [set,key,value]</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">	     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	     */</span></span><br><span class="line">	    <span class="function"><span class="keyword">public</span> String <span class="title">set</span><span class="params">(String key, String value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">	        sb.append(<span class="string">"*3"</span>)</span><br><span class="line">	               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">	               .append(<span class="string">"$"</span>)</span><br><span class="line">	               .append(<span class="string">"set"</span>.length())</span><br><span class="line">	               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">	               .append(<span class="string">"set"</span>)</span><br><span class="line">	               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">	               .append(<span class="string">"$"</span>)</span><br><span class="line">	               .append(key.getBytes().length)</span><br><span class="line">	               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">	               .append(key)</span><br><span class="line">	               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">	               .append(<span class="string">"$"</span>)</span><br><span class="line">	               .append(value.getBytes().length)</span><br><span class="line">	               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">	               .append(value)</span><br><span class="line">	               .append(<span class="string">"\r\n"</span>);</span><br><span class="line">	        System.out.println(sb.toString());</span><br><span class="line">	        socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">	        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	        socket.getInputStream().read(buf);</span><br><span class="line">	        <span class="keyword">return</span> <span class="keyword">new</span> String(buf);</span><br><span class="line">	   &#125;	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 Redis 中的 get 命令 [get,key]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(<span class="string">"*2"</span>)</span><br><span class="line">               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">               .append(<span class="string">"$"</span>)</span><br><span class="line">               .append(<span class="string">"get"</span>.length())</span><br><span class="line">               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">               .append(<span class="string">"get"</span>)</span><br><span class="line">               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">               .append(<span class="string">"$"</span>)</span><br><span class="line">               .append(key.getBytes().length)</span><br><span class="line">               .append(<span class="string">"\r\n"</span>)</span><br><span class="line">               .append(key)</span><br><span class="line">               .append(<span class="string">"\r\n"</span>);</span><br><span class="line">        socket.getOutputStream().write(sb.toString().getBytes());</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        socket.getInputStream().read(buf);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(buf);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">           String set = <span class="keyword">new</span> JavaboyRedisClient().set(<span class="string">"k1"</span>, <span class="string">"面朝大海"</span>);</span><br><span class="line">           System.out.println(set);</span><br><span class="line">           String k1 = <span class="keyword">new</span> JavaboyRedisClient().get(<span class="string">"k1"</span>);</span><br><span class="line">           System.out.println(k1);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-Redis持久化"><a href="#7-Redis持久化" class="headerlink" title="7 Redis持久化"></a>7 Redis持久化</h2><p>Redis 是一个缓存工具，也叫做 NoSQL 数据库，既然是数据库，必然支持数据的持久化操作。在 Redis<br>中，数据库持久化一共有两种方案：</p>
<ol>
<li>快照方式</li>
<li>AOF 日志  </li>
</ol>
<h3 id="7-1-快照"><a href="#7-1-快照" class="headerlink" title="7.1 快照"></a>7.1 快照</h3><h4 id="7-1-1-快照原理"><a href="#7-1-1-快照原理" class="headerlink" title="7.1.1 快照原理"></a>7.1.1 快照原理</h4><p>Redis 使用操作系统的多进程机制来实现快照持久化：Redis 在持久化时，会调用 glibc 函数 fork 一个<br>子进程，然后将快照持久化操作完全交给子进程去处理，而父进程则继续处理客户端请求。在这个过程<br>中，子进程能够看到的内存中的数据在子进程产生的一瞬间就固定下来了，再也不会改变，也就是为什<br>么 Redis 持久化叫做 快照。</p>
<h4 id="7-1-2-具体配置"><a href="#7-1-2-具体配置" class="headerlink" title="7.1.2 具体配置"></a>7.1.2 具体配置</h4><p>在 Redis 中，默认情况下，快照持久化的方式就是开启的。<br>默认情况下会产生一个 dump.rdb 文件，这个文件就是备份下来的文件。当 Redis 启动时，会自动的去<br>加载这个 rdb 文件，从该文件中恢复数据。<br>具体的配置，在 redis.conf中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 表示快照的频率，第一个表示 900 秒内如果有一个键被修改，则进行快照</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"># 快照执行出错后，是否继续处理客户端的写命令</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"># 是否对快照文件进行压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"># 表示生成的快照文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"># 表示生成的快照文件位置</span><br><span class="line">dir .&#x2F;</span><br></pre></td></tr></table></figure>


<h4 id="7-1-3-备份流程"><a href="#7-1-3-备份流程" class="headerlink" title="7.1.3 备份流程"></a>7.1.3 备份流程</h4><ol>
<li>在 Redis 运行过程中，我们可以向 Redis 发送一条 save 命令来创建一个快照。但是需要注意，<br>save 是一个阻塞命令，Redis 在收到 save 命令开始处理备份操作之后，在处理完成之前，将不再<br>处理其他的请求。其他命令会被挂起，所以 save 使用的并不多。</li>
<li>我们一般可以使用 bgsave，bgsave 会 fork 一个子进程去处理备份的事情，不影响父进程处理客<br>户端请求。</li>
<li>我们定义的备份规则，如果有规则满足，也会自动触发 bgsave。</li>
<li>另外，当我们执行 shutdown 命令时，也会触发 save 命令，备份工作完成后，Redis 才会关闭。</li>
<li>用 Redis 搭建主从复制时，在 从机连上主机之后，会自动发送一条 sync 同步命令，主机收到命令<br>之后，首先执行 bgsave 对数据进行快照，然后才会给从机发送快照数据进行同步。</li>
</ol>
<h3 id="7-2-AOF"><a href="#7-2-AOF" class="headerlink" title="7.2 AOF"></a>7.2 AOF</h3><p>与快照持久化不同，AOF 持久化是将被执行的命令追加到 aof 文件末尾，在恢复时，只需要把记录下来<br>的命令从头到尾执行一遍即可。<br>默认情况下，AOF 是没有开启的。我们需要手动开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启 aof 配置</span><br><span class="line">appendonly yes</span><br><span class="line"># AOF 文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"># 备份的时机，下面的配置表示每秒钟备份一次</span><br><span class="line">appendfsync everysec</span><br><span class="line"># 表示 aof 文件在压缩时，是否还继续进行同步操作</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"># 表示当目前 aof 文件大小超过上一次重写时的 aof 文件大小的百分之多少的时候，再次进行重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"># 如果之前没有重写过，则以启动时的 aof 大小为依据，同时要求 aof 文件至少要大于 64M</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure>
<p>同时为了避免快照备份的影响，记得将快照备份关闭:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save &quot;&quot;</span><br><span class="line">#save 900 1</span><br><span class="line">#save 300 10</span><br><span class="line">#save 60 10000</span><br></pre></td></tr></table></figure>
<h2 id="8-Redis事务"><a href="#8-Redis事务" class="headerlink" title="8 Redis事务"></a>8 Redis事务</h2><p>正常来说，一个可以商用的数据库往往都有比较完善的事务支持，Redis 当然也不例外。相对于 关系型<br>数据库中的事务模型，Redis 中的事务要简单很多。因为简单，所以 Redis 中的事务模型不太严格，所<br>以我们不能像使用关系型数据库中的事务那样来使用 Redis。<br>在关系型数据库中，和事务相关的三个指令分别是：</p>
<ul>
<li>begin</li>
<li>commit</li>
<li>rollback<br>在 Redis 中，当然也有对应的指令：</li>
<li>multi</li>
<li>exec</li>
<li>discard</li>
</ul>
<h3 id="8-1-不具原子性"><a href="#8-1-不具原子性" class="headerlink" title="8.1 不具原子性"></a>8.1 不具原子性</h3><p>注意，Redis 中的事务并不能算作原子性。它仅仅具备隔离性，也就是说当前的事务可以不被其他事务<br>打断。<br>由于每一次事务操作涉及到的指令还是比较多的，为了提高执行效率，我们在使用客户端的时候，可以<br>通过 pipeline 来优化指令的执行。<br>Redis 中还有一个 watch 指令，watch 可以用来监控一个 key，通过这种监控，我们可以确保在 exec<br>之前，watch 的键的没有被修改过。</p>
<h3 id="8-2-代码实现"><a href="#8-2-代码实现" class="headerlink" title="8.2 代码实现"></a>8.2 代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Redis().execute(jedis -&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> TransactionTest().saveMoney(jedis, <span class="string">"javaboy"</span>, <span class="number">1000</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">saveMoney</span><span class="params">(Jedis jedis, String userId, Integer money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            jedis.watch(userId);</span><br><span class="line">            <span class="keyword">int</span> v = Integer.parseInt(jedis.get(userId)) + money;</span><br><span class="line">            Transaction tx = jedis.multi();</span><br><span class="line">            tx.set(userId, String.valueOf(v));</span><br><span class="line">            List&lt;Object&gt; exec = tx.exec();</span><br><span class="line">            <span class="keyword">if</span> (exec != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(jedis.get(userId));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Redis主从同步"><a href="#9-Redis主从同步" class="headerlink" title="9 Redis主从同步"></a>9 Redis主从同步</h2><h3 id="9-1-CAP"><a href="#9-1-CAP" class="headerlink" title="9.1 CAP"></a>9.1 CAP</h3><p>在分布式环境下，CAP 原理是一个非常基础的东西，所有的分布式存储系统，都只能在 CAP 中选择两项实现。</p>
<blockquote>
<p>c：consistent 一致性<br>a：availability 可用性<br>p：partition tolerance 分布式容忍性<br>在一个分布式系统中，这三个只能满足两个：在一个分布式系统中，P 肯定是要实现的，c 和 a 只能选<br>择其中一个。大部分情况下，大多数网站架构选择了 ap。<br>在 Redis 中，实际上就是保证最终一致。<br>Redis 中，当搭建了主从服务之后，如果主从之间的连接断开了，Redis 依然是可以操作的，相当于它<br>满足可用性，但是此时主从两个节点中的数据会有差异，相当于牺牲了一致性。但是 Redis 保证最终一<br>致，就是说当网络恢复的时候，从机会追赶主机，尽量保持数据一致。</p>
</blockquote>
<h3 id="9-2-主从复制"><a href="#9-2-主从复制" class="headerlink" title="9.2 主从复制"></a>9.2 主从复制</h3><p>主从复制可以在一定程度上扩展 redis 性能，redis 的主从复制和关系型数据库的主从复制类似，从机<br>能够精确的复制主机上的内容。实现了主从复制之后，一方面能够实现数据的读写分离，降低master的<br>压力，另一方面也能实现数据的备份。</p>
<h4 id="9-2-1-配置方式"><a href="#9-2-1-配置方式" class="headerlink" title="9.2.1 配置方式"></a>9.2.1 配置方式</h4><p>假设我有三个redis实例，地址分别如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">192.168.91.128:6379  </span><br><span class="line">192.168.91.128:6380  </span><br><span class="line">192.168.91.128:6381</span><br></pre></td></tr></table></figure>
<p>即同一台服务器上三个实例，配置方式如下：</p>
<ol>
<li>将 redis.conf 文件更名为 redis6379.conf，方便我们区分，然后把 redis6379.conf 再复制两份，<br>分别为 redis6380.conf 和 redis6381.conf。如下:<img src="/2020/08/18/Redis%E7%AC%94%E8%AE%B0/4.png" class="" title="This is an example image"></li>
<li>打开 redis6379.conf，将如下配置均加上 6379,(默认是6379的不用修改)，如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 6379</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</span><br><span class="line">logfile &quot;6379.log&quot;</span><br><span class="line">dbfilename dump6379.rdb</span><br><span class="line">appendfilename &quot;appendonly6379.aof&quot;</span><br></pre></td></tr></table></figure></li>
<li>同理，分别打开 redis6380.conf 和 redis6381.conf 两个配置文件，将第二步涉及到 6379 的分别<br>改为 6380 和 6381。</li>
<li>输入如下命令，启动三个redis实例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-4.0.8]# redis-server redis6379.conf</span><br><span class="line">[root@localhost redis-4.0.8]# redis-server redis6380.conf</span><br><span class="line">[root@localhost redis-4.0.8]# redis-server redis6381.conf</span><br></pre></td></tr></table></figure></li>
<li>输入如下命令，分别进入三个实例的控制台：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost redis-4.0.8]# redis-cli -p 6379</span><br><span class="line">[root@localhost redis-4.0.8]# redis-cli -p 6380</span><br><span class="line">[root@localhost redis-4.0.8]# redis-cli -p 6381</span><br></pre></td></tr></table></figure>
此时我就成功配置了三个redis实例了。  </li>
<li>假设在这三个实例中，6379 是主机，即 master，6380 和 6381 是从机，即 slave，那么如何配<br>置这种实例关系呢，很简单，分别在 6380 和 6381 上执行如下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
这一步也可以通过在两个从机的 redis.conf 中添加如下配置来解决：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof 127.0.0.1 6379</span><br></pre></td></tr></table></figure>
OK，主从关系搭建好后，我们可以通过如下命令可以查看每个实例当前的状态，如下:  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; INFO replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;56,lag&#x3D;1</span><br><span class="line">slave1:ip&#x3D;127.0.0.1,port&#x3D;6381,state&#x3D;online,offset&#x3D;56,lag&#x3D;0</span><br><span class="line">master_replid:26ca818360d6510b717e471f3f0a6f5985b6225d</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:56</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:56</span><br></pre></td></tr></table></figure>
我们可以看到 6379 是一个主机，上面挂了两个从机，两个从机的地址、端口等信息都展现出来了。如<br>果我们在 6380 上执行 INFO replication，显示信息如下: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; INFO replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:6</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:630</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_replid:26ca818360d6510b717e471f3f0a6f5985b6225d</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:630</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:630</span><br></pre></td></tr></table></figure>
我们可以看到 6380 是一个从机，从机的信息以及它的主机的信息都展示出来了。  </li>
<li>此时，我们在主机中存储一条数据，在从机中就可以 get 到这条数据了。</li>
</ol>
<h4 id="9-2-2-主从复制注意点"><a href="#9-2-2-主从复制注意点" class="headerlink" title="9.2.2 主从复制注意点"></a>9.2.2 主从复制注意点</h4><ol>
<li>如果主机已经运行了一段时间了，并且了已经存储了一些数据了，此时从机连上来，那么从机会将<br>主机上所有的数据进行备份，而不是从连接的那个时间点开始备份。  </li>
<li>配置了主从复制之后，主机上可读可写，但是从机只能读取不能写入（可以通过修改redis.conf<br>中 slave-read-only 的值让从机也可以执行写操作）。  </li>
<li>在整个主从结构运行过程中，如果主机不幸挂掉，重启之后，他依然是主机，主从复制操作也能够<br>继续进行。 </li>
</ol>
<h4 id="9-2-3-主从复制原理"><a href="#9-2-3-主从复制原理" class="headerlink" title="9.2.3 主从复制原理"></a>9.2.3 主从复制原理</h4><p>每一个 master 都有一个 replication ID，这是一个较大的伪随机字符串，标记了一个给定的数据集。每<br>个 master 也持有一个偏移量，master 将自己产生的复制流发送给 slave 时，发送多少个字节的数据，<br>自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集时，它可以以此更新 slave 的状<br>态。复制偏移量即使在没有一个 slave 连接到 master 时，也会自增，所以基本上每一对给定的<br>Replication ID, offset 都会标识一个 master 数据集的确切版本。当 slave 连接到 master 时，它们使用<br>PSYNC 命令来发送它们记录的旧的 master replication ID 和它们至今为止处理的偏移量。通过这种方<br>式，master 能够仅发送 slave 所需的增量部分。但是如果 master 的缓冲区中没有足够的命令积压缓冲<br>记录，或者如果 slave 引用了不再知道的历史记录（replication ID），则会转而进行一个全量重同步：<br>在这种情况下，slave 会得到一个完整的数据集副本，从头开始(参考redis官网)。<br>简单来说，就是以下几个步骤：  </p>
<ol>
<li>slave 启动成功连接到 master 后会发送一个 sync 命令。  </li>
<li>Master 接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令。</li>
<li>在后台进程执行完毕之后，master 将传送整个数据文件到 slave,以完成一次完全同步。</li>
<li>全量复制：而 slave 服务在接收到数据库文件数据后，将其存盘并加载到内存中。</li>
<li>增量复制：Master 继续将新的所有收集到的修改命令依次传给 slave,完成同步。</li>
<li>但是只要是重新连接 master,一次完全同步（全量复制)将被自动执行。</li>
</ol>
<h4 id="9-2-4-一场接力赛"><a href="#9-2-4-一场接力赛" class="headerlink" title="9.2.4 一场接力赛"></a>9.2.4 一场接力赛</h4><p>在上篇文章中，我们搭建的主从复制模式是下面这样的：</p>

<p>实际上，一主二仆的主从复制，我们可以搭建成下面这种结构：</p>

<p>搭建方式很简单，在前文基础上，我们只需要修改 6381 的 master 即可，在 6381 实例上执行如下命<br>令，让 6381 从 6380 实例上复制数据，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6381&gt; SLAVEOF 127.0.0.1 6380</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>此时，我们再看 6379 的 slave，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;127.0.0.1,port&#x3D;6380,state&#x3D;online,offset&#x3D;0,lag&#x3D;1</span><br><span class="line">master_replid:4a38bbfa37586c29139b4ca1e04e8a9c88793651</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:0</span><br></pre></td></tr></table></figure>
<p>只有一个 slave，就是 6380，我们再看 6380 的信息，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:127.0.0.1</span><br><span class="line">master_port:6379</span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:1</span><br><span class="line">master_sync_in_progress:0</span><br><span class="line">slave_repl_offset:70</span><br><span class="line">slave_priority:100</span><br><span class="line">slave_read_only:1</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip&#x3D;127.0.0.1,port&#x3D;6381,state&#x3D;online,offset&#x3D;70,lag&#x3D;0</span><br><span class="line">master_replid:4a38bbfa37586c29139b4ca1e04e8a9c88793651</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:70</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:70</span><br></pre></td></tr></table></figure>
<p>6380 此时的角色是一个从机，它的主机是 6379，但是 6380 自己也有一个从机，那就是 6381.<br>此时我们的主从结构如下图：</p>


<h4 id="9-2-5-哨兵模式"><a href="#9-2-5-哨兵模式" class="headerlink" title="9.2.5 哨兵模式"></a>9.2.5 哨兵模式</h4><p>结合上篇文章，我们一共介绍了两种主从模式了，但是这两种，不管是哪一种，都会存在这样一个问<br>题，那就是当主机宕机时，就会发生群龙无首的情况，如果在主机宕机时，能够从从机中选出一个来充<br>当主机，那么就不用我们每次去手动重启主机了，这就涉及到一个新的话题，那就是哨兵模式。<br>所谓的哨兵模式，其实并不复杂，我们还是在我们前面的基础上来搭建哨兵模式。假设现在我的<br>master 是 6379，两个从机分别是 6380 和 6381，两个从机都是从 6379 上复制数据。先按照上文的步<br>骤，我们配置好一主二仆，然后在 redis 目录下打开 sentinel.conf 文件，做如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure>
<p>其中 mymaster 是给要监控的主机取的名字，随意取，后面是主机地址，最后面的 2 表示有多少个<br>sentinel 认为主机挂掉了，就进行切换（我这里只有一个，因此设置为1）。好了，配置完成后，输入<br>如下命令启动哨兵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-sentinel sentinel.conf</span><br></pre></td></tr></table></figure>
<p>然后启动我们的一主二仆架构，启动成功后，关闭 master，观察哨兵窗口输出的日志，如下：</p>

<p>可以看到，6379 挂掉之后，redis 内部重新举行了选举，6380 重新上位。此时，如果 6379<br>重启，也不再是扛把子了，只能屈身做一个 slave 了。</p>
<p><strong>注意:</strong><br>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave<br>机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问<br>题更加严重。因此我们还需要集群来进一步提升 redis 性能，这个问题我们将在后面说到。</p>
<h3 id="9-3-Jedis-操作哨兵模式"><a href="#9-3-Jedis-操作哨兵模式" class="headerlink" title="9.3 Jedis 操作哨兵模式"></a>9.3 Jedis 操作哨兵模式</h3><p>准备工作：</p>
<ol>
<li>所有的实例均配置 masterauth （在 redis.conf 配置文件中）</li>
<li>所有实例均需要配置绑定地址：bind 192.168.91.128<br>另外，哨兵配置的时候，监控的 master 也不要直接写 127.0.0.1，按如下方式写：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.91.128 6380 1</span><br></pre></td></tr></table></figure>
做好准备工作，然后启动三个 redis 实例，同时启动哨兵。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sentinel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(<span class="number">10</span>);</span><br><span class="line">        config.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        String master = <span class="string">"mymaster"</span>;</span><br><span class="line">        Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        sentinels.add(<span class="string">"192.168.91.128:26379"</span>);</span><br><span class="line">        JedisSentinelPool sentinelPool = <span class="keyword">new</span> JedisSentinelPool(master,</span><br><span class="line">sentinels, config, <span class="string">"javaboy"</span>);</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                jedis = sentinelPool.getResource();</span><br><span class="line">                String k1 = jedis.get(<span class="string">"k1"</span>);</span><br><span class="line">                System.out.println(k1);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    jedis.close();</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="9-4-SpringBoot操作哨兵模式"><a href="#9-4-SpringBoot操作哨兵模式" class="headerlink" title="9.4 SpringBoot操作哨兵模式"></a>9.4 SpringBoot操作哨兵模式</h3><p>配置 Redis 连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> redis:</span><br><span class="line">   password: javaboy</span><br><span class="line">   timeout: 5000</span><br><span class="line">   sentinel:</span><br><span class="line">     master: mymaster</span><br><span class="line">     nodes: 192.168.91.128:26379</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentinelApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String k1 = redisTemplate.opsForValue().get(<span class="string">"k1"</span>);</span><br><span class="line">                System.out.println(k1);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-Redis集群"><a href="#10-Redis集群" class="headerlink" title="10 Redis集群"></a>10 Redis集群</h2><h3 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h3>
<p>Redis 集群运行原理如下：</p>
<ol>
<li>所有的 Redis 节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽</li>
<li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效</li>
<li>客户端与 Redis 节点直连,不需要中间 proxy 层，客户端不需要连接集群所有节点，连接集群中任<br>何一个可用节点即可</li>
<li>Redis-cluster 把所有的物理节点映射到 [0-16383]slot 上,cluster (簇)负责维护 node&lt;-&gt;slot&lt;-<blockquote>
<p>value 。Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个key-value 时，<br>Redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会<br>对应一个编号在 0-16383 之间的哈希槽，Redis 会根据节点数量大致均等的将哈希槽映射到不同<br>的节点</p>
</blockquote>
</li>
</ol>
<h3 id="怎么样投票"><a href="#怎么样投票" class="headerlink" title="怎么样投票"></a>怎么样投票</h3><p>投票过程是集群中所有 master 参与,如果半数以上 master 节点与 master 节点通信超过 clusternode-timeout 设置的时间,<br>认为当前 master 节点挂掉。</p>
<h3 id="怎样判断节点不可用"><a href="#怎样判断节点不可用" class="headerlink" title="怎样判断节点不可用"></a>怎样判断节点不可用</h3><ol>
<li>如果集群任意 master 挂掉,且当前 master 没有 slave.集群进入 fail 状态,也可以理解成集群的 slot<br>映射 [0-16383] 不完整时进入 fail 状态。</li>
<li>如果集群超过半数以上 master 挂掉，无论是否有 slave,集群进入 fail 状态，当集群不可用时,所有<br>对集群的操作做都不可用，收到((error) CLUSTERDOWN The cluster is down)错误</li>
</ol>
<h3 id="ruby"><a href="#ruby" class="headerlink" title="ruby"></a>ruby</h3><p>Redis 集群管理工具 redis-trib.rb 依赖 ruby 环境，首先需要安装 ruby 环境：<br>安装 ruby:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br></pre></td></tr></table></figure>

<h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p>首先我们对集群做一个简单规划，假设我的集群中一共有三个节点，每个节点一个主机一个从机，这样<br>我一共需要 6 个 Redis 实例。首先创建 redis-cluster 文件夹，在该文件夹下分别创建 7001、7002、<br>7003、7004、7005、7006 文件夹，用来存放我的 Redis 配置文件，如下：</p>

<p>将 Redis 也在 redis-cluster 目录下安装一份，然后将 redis.conf 文件向 7001-7006 这 6 个文件夹中分<br>别拷贝一份，拷贝完成后，分别修改如下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 7001</span><br><span class="line">#bind 127.0.0.1</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-XXXXX7001.conf</span><br><span class="line">protected no</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>
<p>这是 7001 目录下的配置，其他的文件夹将 7001 改为对应的数字即可。修改完成后，进入到 redis 安<br>装目录中，分别启动各个 redis，使用刚刚修改过的配置文件，如下:</p>

<p>执行启动脚本，启动成功后接下来我们就可以进行集群的创建了，首先将 redis/src 目录下的<br>redis-trib.rb 文件拷贝到 redis-cluster 目录下，然后在 redis-cluster 目录下执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-trib.rb create --replicas 1 192.168.248.128:7001 192.168.248.128:7002</span><br><span class="line">192.168.248.128:7003 192.168.248.128:7004 192.168.248.128:7005</span><br><span class="line">192.168.248.128:7006</span><br></pre></td></tr></table></figure>
<p>注意，replicas 后面的 1 表示每个主机都带有 1 个从机，执行过程如下：</p>

<p>注意创建过程的日志，每个redis都获得了一个编号，同时日志也说明了哪些实例做主机，哪些实例做从<br>机，每个从机的主机是谁，每个主机所分配到的hash槽范围等等。</p>
<h3 id="查询集群信息"><a href="#查询集群信息" class="headerlink" title="查询集群信息"></a>查询集群信息</h3><p>集群创建成功后，我们可以登录到 Redis 控制台查看集群信息，注意登录时要添加 -c 参数，表示以集<br>群方式连接，如下：</p>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cluster nodes </span><br><span class="line">&gt; cluster info</span><br></pre></td></tr></table></figure>

<h3 id="添加主节点"><a href="#添加主节点" class="headerlink" title="添加主节点"></a>添加主节点</h3><p>首先我们准备一个端口为 7007 的主节点并启动，准备方式和前面步骤一样，启动成功后，通过如下命<br>令添加主节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-trib.rb add-node 127.0.0.1:7007 127.0.0.1:7001</span><br></pre></td></tr></table></figure>
<p>主节点添加之后，我们可以通过 cluster nodes 命令查看主节点是否添加成功，此时我们发现新添加的<br>节点没有分配到 slot，如下：</p>

<p>没有分配到 slot 将不能存储数据，此时我们需要手动分配 slot，分配命令如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-trib.rb reshard 127.0.0.1:7001</span><br></pre></td></tr></table></figure>
<p>后面的地址为任意一个节点地址，在分配的过程中，我们一共要输入如下几个参数：</p>
<ol>
<li>一共要划分多少个 hash 槽出来？就是我们总共要给新添加的节点分多少 hash 槽，这个参数依实<br>际情况而定，如下：<blockquote>
<blockquote>
<p>How many slots do you want to move (from 1 to 16384)?</p>
</blockquote>
</blockquote>
</li>
<li>这些划分出来的槽要给谁，这里输入 7007 节点的编号，如下：<blockquote>
<blockquote>
<p>what is the receiving node ID? ed23rfdsar23rfds23t23rfewff23fr236456</p>
</blockquote>
</blockquote>
</li>
<li>要让谁出血？因为 hash 槽目前已经全部分配完毕，要重新从已经分好的节点中拿出来一部分给<br>7007，必然要让另外三个节点把吃进去的吐出来，这里我们可以输入多个节点的编号，每次输完<br>一个点击回车，输完所有的输入 done 表示输入完成，这样就让这几个节点让出部分 slot，如果要<br>让所有具有 slot 的节点都参与到此次 slot 重新分配的活动中，那么这里直接输入 all 即可，如下：
OK，主要就是这几个参数，输完之后进入到 slot 重新分配环节，分配完成后，通过 cluster nodes 命<br>令，我们可以发现 7007 已经具有 slot 了，如下：
OK,刚刚我们是添加主节点，我们也可以添加从节点，比如我要把 7008 作为 7007 的从节点，添加方式<br>如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-trib.rb add-node --slave --master-id</span><br><span class="line">79bbb30bba66b4997b9360dd09849c67d2d02bb9 192.168.31.135:7008</span><br><span class="line">192.168.31.135:7007</span><br></pre></td></tr></table></figure>
其中 79bbb30bba66b4997b9360dd09849c67d2d02bb9 是 7007 的编号。</li>
</ol>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除节点也比较简单，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;redis-trib.rb del-node 127.0.0.1:7005 4b45eb75c8b428fbd77ab979b85080146a9bc017</span><br></pre></td></tr></table></figure>
<p>注意 4b45eb75c8b428fbd77ab979b85080146a9bc017 是要删除节点的编号。<br>再注意：删除已经占有 hash 槽的结点会失败，报错如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again</span><br></pre></td></tr></table></figure>
<p>需要将该节点占用的 hash 槽分配出去（分配方式与上文一致，不赘述）。</p>
<h3 id="Jedis操作RedisCluster"><a href="#Jedis操作RedisCluster" class="headerlink" title="Jedis操作RedisCluster"></a>Jedis操作RedisCluster</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RedisCluster &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Set&lt;HostAndPort&gt; nodes &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">        nodes.add(new HostAndPort(&quot;192.168.91.128&quot;, 7001));</span><br><span class="line">        nodes.add(new HostAndPort(&quot;192.168.91.128&quot;, 7002));</span><br><span class="line">        nodes.add(new HostAndPort(&quot;192.168.91.128&quot;, 7003));</span><br><span class="line">        nodes.add(new HostAndPort(&quot;192.168.91.128&quot;, 7004));</span><br><span class="line">        nodes.add(new HostAndPort(&quot;192.168.91.128&quot;, 7005));</span><br><span class="line">        nodes.add(new HostAndPort(&quot;192.168.91.128&quot;, 7006));</span><br><span class="line">        nodes.add(new HostAndPort(&quot;192.168.91.128&quot;, 7007));</span><br><span class="line">        JedisPoolConfig config &#x3D; new JedisPoolConfig();</span><br><span class="line">        &#x2F;&#x2F;连接池最大空闲数</span><br><span class="line">        config.setMaxIdle(300);</span><br><span class="line">        &#x2F;&#x2F;最大连接数</span><br><span class="line">        config.setMaxTotal(1000);</span><br><span class="line">        &#x2F;&#x2F;连接最大等待时间，如果是 -1 表示没有限制</span><br><span class="line">        config.setMaxWaitMillis(30000);</span><br><span class="line">        &#x2F;&#x2F;在空闲时检查有效性</span><br><span class="line">        config.setTestOnBorrow(true);</span><br><span class="line">        JedisCluster cluster &#x3D; new JedisCluster(nodes, 15000, 15000, 5,</span><br><span class="line">&quot;javaboy&quot;, config);</span><br><span class="line">        String set &#x3D; cluster.set(&quot;k1&quot;, &quot;v1&quot;);</span><br><span class="line">        System.out.println(set);</span><br><span class="line">        String k1 &#x3D; cluster.get(&quot;k1&quot;);</span><br><span class="line">        System.out.println(k1);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>开发手册</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义注解实现请求幂等性demo</title>
    <url>/2020/08/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E5%B9%82%E7%AD%89%E6%80%A7demo/</url>
    <content><![CDATA[<p>实现请求幂等性方式很多：</p>
<ol>
<li>数据库建立唯一索引</li>
<li>token机制,每次接口请求前先获取请求携带的token，然后再下次请求的时候加上这个token，后台进行验证，如果验证通过则删除token。</li>
<li>数据库先查询后判断，如果存在则证明已经请求过了，没有则说明是第一次</li>
<li>悲观锁或者乐观锁，执行sql操作时，其他sql无法执行update。</li>
</ol>
<p>本demo实现用自定义注解实现请求幂等性，<a href="https://github.com/airflowshu/idemcompoent" target="_blank">实例demo代码：点我</a><br>具体有两种方式</p>
<a id="more"></a>
<h1 id="1-使用自定义注解实现请求幂等性"><a href="#1-使用自定义注解实现请求幂等性" class="headerlink" title="1 使用自定义注解实现请求幂等性"></a>1 使用自定义注解实现请求幂等性</h1><p>实现思路：</p>
<ol>
<li>创建自定义注解 @IdemAnnotation</li>
<li>自定义拦截器IdemInterceptor进行注解拦截</li>
<li>使用WebMvcConfigurer注册自定义拦截器，使请求时拦截生效</li>
</ol>
<p>具体实现：<br>目录结构如图：<img src="/2020/08/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E5%B9%82%E7%AD%89%E6%80%A7demo/1.png" class="" title="This is an example image"></p>
<p>创建一个springBoot项目，引入redis和spring-web,在application.properties中配置好本地启动的redis的host和port以及密码</p>
<h2 id="1-1-创建自定义注解-IdemAnnotation"><a href="#1-1-创建自定义注解-IdemAnnotation" class="headerlink" title="1.1 创建自定义注解 @IdemAnnotation"></a>1.1 创建自定义注解 @IdemAnnotation</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IdemAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-1-创建RedisService"><a href="#1-1-1-创建RedisService" class="headerlink" title="1.1.1 创建RedisService"></a>1.1.1 创建RedisService</h3><p>RedisService实现三个方法:setEx存放token,判断是否存在token,和执行通过首次请求后的移除token的remove()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">setEx</span><span class="params">(String key,Object value,Long expireTime)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">            ops.set(key,value);</span><br><span class="line">            redisTemplate.expire(key, expireTime, TimeUnit.SECONDS);</span><br><span class="line">            result =<span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exsits</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exsits(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.delete(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-创建TokenService"><a href="#1-1-2-创建TokenService" class="headerlink" title="1.1.2 创建TokenService"></a>1.1.2 创建TokenService</h3><p>TokenService 主要有两个方法：创建token；判断是否存在token参数，没有就抛异常，有则返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisService redisService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">createToken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s = UUID.randomUUID().toString();</span><br><span class="line">        redisService.setEx(s,s,<span class="number">100L</span>);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkTokenExsits</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> TokenException </span>&#123;</span><br><span class="line">        String token = request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(token))&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isEmpty(request.getParameter(<span class="string">"token"</span>)))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TokenException(<span class="string">"token不存在"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!redisService.exsits(token)) &#123;</span><br><span class="line">            <span class="comment">//可能被移除了，抛出为重复的操作</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TokenException(<span class="string">"重复的操作"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述都没抛出，则认为是第一次请求</span></span><br><span class="line">        <span class="keyword">return</span> redisService.remove(token);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-创建IdemInterceptor"><a href="#1-2-创建IdemInterceptor" class="headerlink" title="1.2 创建IdemInterceptor"></a>1.2 创建IdemInterceptor</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdemInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先判断这次handler是不是自定义注解方法handler，因为自定义注解的IdemAnnotion是作用于方法上</span></span><br><span class="line">        <span class="keyword">if</span> (!(handler <span class="keyword">instanceof</span> HandlerMethod)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Method method = ((HandlerMethod) handler).getMethod();</span><br><span class="line">        IdemAnnotation idemAnnotation = method.getAnnotation(IdemAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//对注解方法进行判断</span></span><br><span class="line">        <span class="keyword">if</span> (idemAnnotation !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//如果是幂等注解</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> tokenService.checkTokenExsits(request);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TokenException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="comment">//可以用全局异常处理去接受处理</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-注册实现拦截器进行注解拦截"><a href="#1-3-注册实现拦截器进行注解拦截" class="headerlink" title="1.3 注册实现拦截器进行注解拦截"></a>1.3 注册实现拦截器进行注解拦截</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    IdemInterceptor idemInterceptor;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(idemInterceptor).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-创建HelloTest进行测试"><a href="#1-4-创建HelloTest进行测试" class="headerlink" title="1.4 创建HelloTest进行测试"></a>1.4 创建HelloTest进行测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenService tokenService;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getToken"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tokenService.createToken();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="meta">@IdemAnnotation</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hello方法上加了@IdemAnnotation，hello2未加以做比较。<br>当执行了getToken请求获取了token后，在redis里存入了改token；</p>
<img src="/2020/08/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E5%B9%82%E7%AD%89%E6%80%A7demo/3.png" class="" title="This is an example image">
<p>我们把token放入请求header中，然后执行hello请求后会进行注解拦截，</p>
<img src="/2020/08/19/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E5%B9%82%E7%AD%89%E6%80%A7demo/2.png" class="" title="This is an example image">
<p>当第一次执行hello，成功返回“hello”；再次执行时，会返回“重复的操作”。</p>
<p><strong>总结：</strong><br>自定义注解的这套流程在实现请求幂等性或实现权限控制等其他流程操作也是一样的道理，可以参考其实现方式进行。</p>
<h1 id="2-AOP方式实现注解生效"><a href="#2-AOP方式实现注解生效" class="headerlink" title="2 AOP方式实现注解生效"></a>2 AOP方式实现注解生效</h1><p>实现思路：</p>
<ol>
<li>maven添加aop依赖，创建aop实现类AnnotationAspect，添加@Component和@Aspect使生效</li>
<li>AnnotationAspect内部实现@PointCut切点和@Before前置操作</li>
<li>在前置操作中进行request请求的token判断</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: idemcompoent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 替代拦截器方式；使用AOP 实现注解生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Wangts</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2020-08-21 13:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenService tokenService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.example.idemcompoent.annotation.IdemAnnotation)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> <span class="keyword">throws</span> TokenException </span>&#123;</span><br><span class="line">        ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();</span><br><span class="line">        HttpServletRequest request = requestAttributes.getRequest();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             tokenService.checkTokenExsits(request);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">//可以用全局异常处理去接受处理</span></span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该种方式同样能实现注解生效。具体两次操作可以参考git提交版本记录进行差异比较。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中Stream用法</title>
    <url>/2020/08/25/Java8%E4%B8%ADStream%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>本文主要整理了Java8的新特性Stream的用法，可以利用新特性的简洁代码实现一些数据转化、处理。</p>
<a id="more"></a>
<!-- 注释首府 -->
<p><strong>定义一个Apple对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal money;</span><br><span class="line">    <span class="keyword">private</span> Integer num;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Apple</span><span class="params">(Integer id, String name, BigDecimal money, Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>添加一些测试数据：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; appleList = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//存放apple对象集合</span></span><br><span class="line"> </span><br><span class="line">Apple apple1 =  <span class="keyword">new</span> Apple(<span class="number">1</span>,<span class="string">"苹果1"</span>,<span class="keyword">new</span> BigDecimal(<span class="string">"3.25"</span>),<span class="number">10</span>);</span><br><span class="line">Apple apple12 = <span class="keyword">new</span> Apple(<span class="number">1</span>,<span class="string">"苹果2"</span>,<span class="keyword">new</span> BigDecimal(<span class="string">"1.35"</span>),<span class="number">20</span>);</span><br><span class="line">Apple apple2 =  <span class="keyword">new</span> Apple(<span class="number">2</span>,<span class="string">"香蕉"</span>,<span class="keyword">new</span> BigDecimal(<span class="string">"2.89"</span>),<span class="number">30</span>);</span><br><span class="line">Apple apple3 =  <span class="keyword">new</span> Apple(<span class="number">3</span>,<span class="string">"荔枝"</span>,<span class="keyword">new</span> BigDecimal(<span class="string">"9.99"</span>),<span class="number">40</span>);</span><br><span class="line"> </span><br><span class="line">appleList.add(apple1);</span><br><span class="line">appleList.add(apple12);</span><br><span class="line">appleList.add(apple2);</span><br><span class="line">appleList.add(apple3);</span><br></pre></td></tr></table></figure>
<h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>List里面的对象元素，以某个属性来分组，例如，以id分组，将id相同的放在一起：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//List 以ID分组 Map&lt;Integer,List&lt;Apple&gt;&gt;</span></span><br><span class="line">Map&lt;Integer, List&lt;Apple&gt;&gt; groupBy = appleList.stream().collect(Collectors.groupingBy(Apple::getId));</span><br><span class="line"> </span><br><span class="line">System.err.println(<span class="string">"groupBy:"</span>+groupBy);</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123; 1=[Apple&#123;id=1, name='苹果1', money=3.25, num=10&#125;,</span><br><span class="line">	Apple&#123;id=1, name='苹果2', money=1.35, num=20&#125;],</span><br><span class="line">  2=[Apple&#123;id=2, name='香蕉', money=2.89, num=30&#125;], </span><br><span class="line">  3=[Apple&#123;id=3, name='荔枝', money=9.99, num=40&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="List转Map"><a href="#List转Map" class="headerlink" title="List转Map"></a>List转Map</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Collectors.toMap 有三个重载方法：</span><br><span class="line"></span><br><span class="line">toMap(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper, <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper);</span><br><span class="line">toMap(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper, <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction);</span><br><span class="line">toMap(<span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends K&gt; keyMapper, <span class="built_in">Function</span>&lt;? <span class="keyword">super</span> T, ? extends U&gt; valueMapper,BinaryOperator&lt;U&gt; mergeFunction, Supplier&lt;M&gt; mapSupplier);</span><br></pre></td></tr></table></figure>
<p>参数含义分别是：</p>
<p>keyMapper：Key 的映射函数</p>
<p>valueMapper：Value 的映射函数</p>
<p>mergeFunction：当 Key 冲突时，调用的合并方法</p>
<p>mapSupplier：Map 构造器，在需要返回特定的 Map 时使用</p>
<p>还是用上面的例子，如果 List 中 userId 有相同的，使用上面的写法会抛异常：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * List -&gt; Map</span></span><br><span class="line"><span class="comment"> * 需要注意的是：</span></span><br><span class="line"><span class="comment"> * toMap 如果集合对象有重复的key，会报错Duplicate key ....</span></span><br><span class="line"><span class="comment"> *  apple1,apple12的id都为1。</span></span><br><span class="line"><span class="comment"> *  可以用 (k1,k2)-&gt;k1 来设置，如果有重复的key,则保留key1,舍弃key2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a);</span><br><span class="line">或者</span><br><span class="line">Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, Function.identity());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常：</span></span><br><span class="line">java.lang.IllegalStateException: Duplicate key id=<span class="number">1</span> </span><br><span class="line">    at java.util.stream.Collectors.lambda$throwingMerger$<span class="number">114</span>(Collectors.java:<span class="number">133</span>)</span><br><span class="line">    at java.util.HashMap.merge(HashMap.java:<span class="number">1245</span>)</span><br><span class="line">    at java.util.stream.Collectors.lambda$toMap$<span class="number">172</span>(Collectors.java:<span class="number">1320</span>)</span><br><span class="line">    at java.util.stream.ReduceOps$<span class="number">3</span>ReducingSink.accept(ReduceOps.java:<span class="number">169</span>)</span><br><span class="line">    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:<span class="number">1374</span>)</span><br><span class="line">    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:<span class="number">481</span>)</span><br><span class="line">    at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:<span class="number">471</span>)</span><br><span class="line">    at java.util.stream.ReduceOps$ReduceOp.evaluateSequential(ReduceOps.java:<span class="number">708</span>)</span><br><span class="line">    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="number">234</span>)</span><br><span class="line">    at java.util.stream.ReferencePipeline.collect(ReferencePipeline.java:<span class="number">499</span>)</span><br><span class="line">    at Test.toMap(Test.java:<span class="number">17</span>)</span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">Map&lt;Integer, Apple&gt; appleMap = appleList.stream().collect(Collectors.toMap(Apple::getId, a -&gt; a,(k1,k2)-&gt;k1));</span><br><span class="line"><span class="comment">//输出的appleMap:</span></span><br><span class="line">&#123;<span class="number">1</span>=Apple&#123;id=<span class="number">1</span>, name=<span class="string">'苹果1'</span>, money=<span class="number">3.25</span>, num=<span class="number">10</span>&#125;, <span class="number">2</span>=Apple&#123;id=<span class="number">2</span>, name=<span class="string">'香蕉'</span>, money=<span class="number">2.89</span>, num=<span class="number">30</span>&#125;, <span class="number">3</span>=Apple&#123;id=<span class="number">3</span>, name=<span class="string">'荔枝'</span>, money=<span class="number">9.99</span>, num=<span class="number">40</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>第四个参数（mapSupplier）用于自定义返回 Map 类型，比如我们希望返回的 Map 是根据 Key 排序的，可以使用如下写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;User&gt; userList = Lists.newArrayList(</span><br><span class="line">        <span class="keyword">new</span> User().setId(<span class="string">"B"</span>).setName(<span class="string">"张三"</span>),</span><br><span class="line">        <span class="keyword">new</span> User().setId(<span class="string">"A"</span>).setName(<span class="string">"李四"</span>),</span><br><span class="line">        <span class="keyword">new</span> User().setId(<span class="string">"C"</span>).setName(<span class="string">"王五"</span>)</span><br><span class="line">);</span><br><span class="line">userList.stream().collect(</span><br><span class="line">    Collectors.toMap(User::getId, User::getName, (n1, n2) -&gt; n1, TreeMap::<span class="keyword">new</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line">A-&gt; 李四 </span><br><span class="line">B-&gt; 张三 </span><br><span class="line">C-&gt; 王五</span><br></pre></td></tr></table></figure>

<h2 id="过滤Filter"><a href="#过滤Filter" class="headerlink" title="过滤Filter"></a>过滤Filter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从集合中过滤出来符合条件的元素：</span></span><br><span class="line">List&lt;Apple&gt; filterList = appleList.stream().filter(a -&gt; a.getName().equals(<span class="string">"香蕉"</span>)).collect(Collectors.toList());</span><br><span class="line"> </span><br><span class="line">System.err.println(<span class="string">"filterList:"</span>+filterList);</span><br><span class="line">[Apple&#123;id=<span class="number">2</span>, name=<span class="string">'香蕉'</span>, money=<span class="number">2.89</span>, num=<span class="number">30</span>&#125;]</span><br></pre></td></tr></table></figure>
<h2 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h2><p>将集合中的数据按照某个属性求和:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算 总金额</span></span><br><span class="line">BigDecimal totalMoney = appleList.stream().map(Apple::getMoney).reduce(BigDecimal.ZERO, BigDecimal::add);</span><br><span class="line">System.err.println(<span class="string">"totalMoney:"</span>+totalMoney);  <span class="comment">//totalMoney:17.48</span></span><br></pre></td></tr></table></figure>
<h2 id="查找流中最大-最小值"><a href="#查找流中最大-最小值" class="headerlink" title="查找流中最大 最小值"></a>查找流中最大 最小值</h2><p>Collectors.maxBy 和 Collectors.minBy 来计算流中的最大或最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Dish&gt; maxDish = Dish.menu.stream().</span><br><span class="line">      collect(Collectors.maxBy(Comparator.comparing(Dish::getCalories)));</span><br><span class="line">maxDish.ifPresent(System.out::println);</span><br><span class="line"> </span><br><span class="line">Optional&lt;Dish&gt; minDish = Dish.menu.stream().</span><br><span class="line">      collect(Collectors.minBy(Comparator.comparing(Dish::getCalories)));</span><br><span class="line">minDish.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.comparingLong;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.collectingAndThen;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.toCollection;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 根据id去重</span></span><br><span class="line">     List&lt;Person&gt; unique = appleList.stream().collect(</span><br><span class="line">                collectingAndThen(toCollection(</span><br><span class="line">				() -&gt; <span class="keyword">new</span> TreeSet&lt;&gt;(comparingLong(Apple::getId))), ArrayList::<span class="keyword">new</span>)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<p>下表展示 Collectors 类的静态工厂方法</p>
<table>
<thead>
<tr>
<th>工厂方法</th>
<th>返回类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>toList</td>
<td>List<T></td>
<td>把流中所有项目收集到一个 List</td>
</tr>
<tr>
<td>toSet</td>
<td>Set<T></td>
<td>把流中所有项目收集到一个 Set，删除重复项</td>
</tr>
<tr>
<td>toCollection</td>
<td>Collection<T></td>
<td>把流中所有项目收集到给定的供应源创建的集合menuStream.collect(toCollection(), ArrayList::new)</td>
</tr>
<tr>
<td>counting</td>
<td>Long</td>
<td>计算流中元素的个数</td>
</tr>
<tr>
<td>sumInt</td>
<td>Integer</td>
<td>对流中项目的一个整数属性求和</td>
</tr>
<tr>
<td>averagingInt</td>
<td>Double</td>
<td>计算流中项目 Integer 属性的平均值</td>
</tr>
<tr>
<td>summarizingInt</td>
<td>IntSummaryStatistics</td>
<td>收集关于流中项目 Integer 属性的统计值，例如最大、最小、 总和与平均值</td>
</tr>
<tr>
<td>joining</td>
<td>String</td>
<td>连接对流中每个项目调用 toString 方法所生成的字符串collect(joining(“, “))</td>
</tr>
<tr>
<td>maxBy</td>
<td>Optional<T></td>
<td>一个包裹了流中按照给定比较器选出的最大元素的 Optional， 或如果流为空则为 Optional.empty()</td>
</tr>
<tr>
<td>minBy</td>
<td>Optional<T></td>
<td>一个包裹了流中按照给定比较器选出的最小元素的 Optional， 或如果流为空则为 Optional.empty()</td>
</tr>
<tr>
<td>reducing</td>
<td>归约操作产生的类型</td>
<td>从一个作为累加器的初始值开始，利用 BinaryOperator 与流 中的元素逐个结合，从而将流归约为单个值累加int totalCalories = menuStream.collect(reducing(0, Dish::getCalories, Integer::sum));</td>
</tr>
<tr>
<td>collectingAndThen</td>
<td>转换函数返回的类型</td>
<td>包裹另一个收集器，对其结果应用转换函数int howManyDishes = menuStream.collect(collectingAndThen(toList(), List::size))</td>
</tr>
<tr>
<td>groupingBy</td>
<td>Map&lt;K, List<T>&gt;</td>
<td>根据项目的一个属性的值对流中的项目作问组，并将属性值作 为结果 Map 的键</td>
</tr>
<tr>
<td>partitioningBy</td>
<td>Map&lt;Boolean,List<T>&gt;</td>
<td>根据对流中每个项目应用谓词的结果来对项目进行分区</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>Stream用法</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/2020/08/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>本文主要涉及到以下内容：</p>
<ul>
<li><p>线程池的定义</p>
</li>
<li><p>Executors创建线程池的几种方式</p>
</li>
<li><p>ThreadPoolExecutor对象</p>
</li>
<li><p>线程池执行任务逻辑和线程池参数的关系</p>
</li>
<li><p>Executors创建返回ThreadPoolExecutor对象</p>
</li>
<li><p>OOM异常测试</p>
</li>
<li><p>如何定义线程池参数</p>
</li>
<li><p>semaphore线程限流</p>
<a id="more"></a>
<h2 id="线程池的定义"><a href="#线程池的定义" class="headerlink" title="线程池的定义"></a>线程池的定义</h2><p>管理一组工作线程。通过线程池复用线程有以下几点优点：</p>
</li>
<li><p>减少资源创建 =&gt; 减少内存开销，创建线程占用内存</p>
</li>
<li><p>降低系统开销 =&gt; 创建线程需要时间，会延迟处理的请求</p>
</li>
<li><p>提高稳定稳定性 =&gt; 避免无限创建线程引起的OutOfMemoryError【简称OOM】</p>
</li>
</ul>
<h2 id="Excutors创建线程池的方式"><a href="#Excutors创建线程池的方式" class="headerlink" title="Excutors创建线程池的方式"></a>Excutors创建线程池的方式</h2><p>根据返回的对象类型创建线程池可以分为三类：</p>
<ul>
<li>创建返回ThreadPoolExecutor对象</li>
<li>创建返回ScheduleThreadPoolExecutor对象</li>
<li>创建返回ForkJoinPool对象</li>
</ul>
<p>本文只讨论创建返回ThreadPoolExecutor对象</p>
<h2 id="ThreadPoolExcutor对象"><a href="#ThreadPoolExcutor对象" class="headerlink" title="ThreadPoolExcutor对象"></a>ThreadPoolExcutor对象</h2><p>在介绍Executors创建线程池方法前先介绍一下ThreadPoolExecutor，因为这些创建线程池的静态方法都是返回ThreadPoolExecutor对象，和我们手动创建ThreadPoolExecutor对象的区别就是我们不需要自己传构造函数的参数。</p>
<p>ThreadPoolExecutor的构造函数共有四个，但最终调用的都是同一个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>
<p>构造参数说明：</p>
<ul>
<li>corePoolSize:核心线程数（一直存在的可用线程数）</li>
<li>maximumPoolSize:最大可用线程数</li>
<li>keepAliveTime:闲置线程的保活时间（超过保活时间则被线程池回收）</li>
<li>unit：保活时间单位</li>
<li>BolckingQuene:线程池所使用的缓冲队列（当请求线程数超过核心线程数后，在workQuene排队等待可用线程的调用）</li>
<li>ThreadFactory:线程池创建线程所用的工厂</li>
<li>RejectedExecutionHandler: 线程池对拒绝任务的处理策略</li>
</ul>
<img src="/2020/08/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/1.jpg" class="" title="test1">
<p>执行逻辑说明：</p>
<ul>
<li>判断核心线程数是否已满，核心线程数大小和corePoolSize参数有关，未满则创建线程执行任务</li>
<li>若核心线程池已满，判断队列是否满，队列是否满和workQueue参数有关，若未满则加入队列中</li>
<li>若队列已满，判断线程池是否已满，线程池是否已满和maximumPoolSize参数有关，若未满创建线程执行任务</li>
<li>若线程池已满，则采用拒绝策略处理无法执执行的任务，拒绝策略和handler参数有关</li>
</ul>
<h2 id="Executors创建返回ThreadPoolExecutor三种对象"><a href="#Executors创建返回ThreadPoolExecutor三种对象" class="headerlink" title="Executors创建返回ThreadPoolExecutor三种对象"></a>Executors创建返回ThreadPoolExecutor三种对象</h2><p>Executors创建返回ThreadPoolExecutor对象的方法共有三种：</p>
<ul>
<li>Executors#newCachedThreadPool =&gt; 创建可缓存的线程池</li>
<li>Executors#newSingleThreadExecutor =&gt; 创建单线程的线程池</li>
<li>Executors#newFixedThreadPool =&gt; 创建固定长度的线程池</li>
</ul>
<h3 id="newCachedThreadPool方法"><a href="#newCachedThreadPool方法" class="headerlink" title="#newCachedThreadPool方法"></a>#newCachedThreadPool方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队里永远是满的，<br>因此最终会创建非核心线程来执行任务。对于非核心线程空闲60s时将被回收。<strong>因为Integer.MAX_VALUE非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起OOM异常</strong></p>
<h3 id="newSingleThreadExecutor方法"><a href="#newSingleThreadExecutor方法" class="headerlink" title="#newSingleThreadExecutor方法"></a>#newSingleThreadExecutor方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">		(<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">								<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">								<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个任务提交时，首先会创建一个核心线程来执行任务，如果超过核心线程的数量，将会放入队列中，<br><strong>因为LinkedBlockingQueue是长度为Integer.MAX_VALUE的队列，可以认为是无界队列，因此往队列中可以插入无限多的任务，在资源有限的时候容易引起OOM异常，</strong><br>同时因为无界队列，maximumPoolSize和keepAliveTime参数将无效，压根就不会创建非核心线程</p>
<h3 id="newFixedThreadPool方法"><a href="#newFixedThreadPool方法" class="headerlink" title="#newFixedThreadPool方法"></a>#newFixedThreadPool方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FixedThreadPool是固定核心线程的线程池，固定核心线程数由用户传入。<br>LinkedBlockingQueue和SingleThreadExecutor类似，唯一的区别就是核心线程数不同，并且由于使用的是LinkedBlockingQueue，在资源有限的时候容易引起OOM异常</p>
<p><strong>总结：</strong></p>
<p>FixedThreadPool和SingleThreadExecutor =&gt; 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常<br>CachedThreadPool =&gt; 允许创建的线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而引起OOM异常</p>
<p>这就是为什么禁止使用Executors去创建线程池，而是推荐自己去创建ThreadPoolExecutor的原因。</p>
<h2 id="OOM异常测试"><a href="#OOM异常测试" class="headerlink" title="OOM异常测试"></a>OOM异常测试</h2><p>理论上会出现OOM异常，必须测试一波验证之前的说法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            es.submit(<span class="keyword">new</span> Task(i++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Executors创建的CachedThreadPool，往线程池中无限添加线程在启动测试类之前先将JVM内存调整小一点，不然很容易将电脑跑出问题【别问我为什么知道，是铁憨憨甜没错了！！！】，在idea里：Run -&gt; Edit Configurations</p>
<img src="/2020/08/26/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/2.jpg" class="" title="test2">
<p>JVM参数说明：</p>
<ul>
<li>-Xms10M =&gt; Java Heap内存初始化值</li>
<li>-Xmx10M =&gt; Java Heap内存最大值</li>
<li>运行结果：<br>  Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread “main”<br>  Disconnected from the target VM, address: ‘127.0.0.1:60416’, transport: ‘socket’</li>
</ul>
<p>创建到3w多个线程的时候开始报OOM错误</p>
<p>另外两个线程池就不做测试了，测试方法一致，只是创建的线程池不一样。</p>
<h2 id="如何定义线程池参数"><a href="#如何定义线程池参数" class="headerlink" title="如何定义线程池参数"></a>如何定义线程池参数</h2><p><strong>CPU密集型</strong> =&gt; 线程池的大小推荐为CPU数量 + 1，CPU数量可以根据Runtime.availableProcessors方法获取</p>
<p><strong>IO密集型</strong> =&gt; CPU数量 * CPU利用率 * (1 + 线程等待时间/线程CPU时间)</p>
<p><strong>混合型</strong> =&gt; 将任务分为CPU密集型和IO密集型，然后分别使用不同的线程池去处理，从而使每个线程池可以根据各自的工作负载来调整</p>
<p><strong>阻塞队列</strong> =&gt; 推荐使用有界队列，有界队列有助于避免资源耗尽的情况发生</p>
<p><strong>拒绝策略</strong> =&gt; 默认采用的是AbortPolicy拒绝策略，直接在程序中抛出RejectedExecutionException异常【因为是运行时异常，不强制catch】，这种处理方式不够优雅。处理拒绝策略有以下几种比较推荐：</p>
<ul>
<li>在程序中捕获RejectedExecutionException异常，在捕获异常中对任务进行处理。针对默认拒绝策略</li>
<li>使用CallerRunsPolicy拒绝策略，该策略会将任务交给调用execute的线程执行【一般为主线程】，此时主线程将在一段时间内不能提交任何任务，从而使工作线程处理正在执行的任务。此时提交的线程将被保存在TCP队列中，TCP队列满将会影响客户端，这是一种平缓的性能降低</li>
<li>自定义拒绝策略，只需要实现RejectedExecutionHandler接口即可</li>
<li>如果任务不是特别重要，使用DiscardPolicy和DiscardOldestPolicy拒绝策略将任务丢弃也是可以的</li>
</ul>
<p>如果使用Executors的静态方法创建ThreadPoolExecutor对象，可以通过使用Semaphore对任务的执行进行限流也可以避免出现OOM异常。</p>
<h2 id="Semaphore限流"><a href="#Semaphore限流" class="headerlink" title="Semaphore限流"></a>Semaphore限流</h2><p>Semaphore 是一个计数信号量，必须由获取它的线程释放。</p>
<p>常用于限制可以访问某些资源的线程数量，例如通过 Semaphore 限流。</p>
<p>Semaphore 只有3个操作：</p>
<ol>
<li>初始化</li>
<li>增加</li>
<li>减少</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudySemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//信号量，只允许 3个线程同时访问</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> num = i;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//获取许可</span></span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        <span class="comment">//执行</span></span><br><span class="line">                        System.out.println(<span class="string">"Accessing: "</span> + num);</span><br><span class="line">                        Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 模拟随机执行时长</span></span><br><span class="line">                        <span class="comment">//释放</span></span><br><span class="line">                        semaphore.release();</span><br><span class="line">                        System.out.println(<span class="string">"Release..."</span> + num);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"C:\Program Files\Java\jdk1.8.0_251\bin\java.exe"</span> </span><br><span class="line">Accessing: <span class="number">0</span></span><br><span class="line">Accessing: <span class="number">2</span></span><br><span class="line">Accessing: <span class="number">1</span></span><br><span class="line">Release..<span class="number">.2</span></span><br><span class="line">Accessing: <span class="number">3</span></span><br><span class="line">Release..<span class="number">.0</span></span><br><span class="line">Accessing: <span class="number">6</span></span><br><span class="line">Release..<span class="number">.1</span></span><br><span class="line">Accessing: <span class="number">5</span></span><br><span class="line">Release..<span class="number">.3</span></span><br><span class="line">Accessing: <span class="number">4</span></span><br><span class="line">Release..<span class="number">.6</span></span><br><span class="line">Accessing: <span class="number">7</span></span><br><span class="line">Release..<span class="number">.7</span></span><br><span class="line">Accessing: <span class="number">8</span></span><br><span class="line">Release..<span class="number">.8</span></span><br><span class="line">Accessing: <span class="number">9</span></span><br><span class="line">Release..<span class="number">.5</span></span><br><span class="line">Release..<span class="number">.4</span></span><br><span class="line">Release..<span class="number">.9</span></span><br><span class="line"></span><br><span class="line">Process finished <span class="keyword">with</span> exit code <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>我们点开Semaphore这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Semaphore&#125; with the given number of</span></span><br><span class="line"><span class="comment"> * permits and nonfair fairness setting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the initial number of permits available.</span></span><br><span class="line"><span class="comment"> *        This value may be negative, in which case releases</span></span><br><span class="line"><span class="comment"> *        must occur before any acquires will be granted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">	sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Semaphore是个非公平锁，线程执行时无序随机的。所以有上述执行结果。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>线程</category>
      </categories>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化</title>
    <url>/2020/09/01/MySQL%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>MySQL优化的知识点整理成树状图。</p>
<img src="/2020/09/01/MySQL%E4%BC%98%E5%8C%96/1.jpg" class="" title="MySQLyouhua">


]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA远程调试教程步骤</title>
    <url>/2020/09/04/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<p> 本文分为两部分：</p>
<ol>
<li>用IDEA远程调试linux下的Tomcat</li>
<li>用IDEA远程调试linux下的SpringBoot项目<a id="more"></a>
<blockquote>
<p>本文Idea版本：2020.1 Ultimate<br>linux:centOS 6.5</p>
</blockquote>
</li>
</ol>
<p>Edit Configuration里添加Remote配置<br><img src="IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4_files/1.jpg" alt=""></p>
<img src="/2020/09/04/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4/1.jpg" class="">
<p><img src="IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4_files/2.jpg" alt=""></p>
<img src="/2020/09/04/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4/2.jpg" class="">
<p>根据上图标记的区域进行对应配置，具体配置项说明如下：</p>
<ul>
<li>Name:随便取，方便区分对应调试的模块</li>
<li>Debugger Mode: <blockquote>
<blockquote>
<p>Attach：此种模式下，调试服务端（被调试远程运行的机器）启动一个端口等待我们（调试客户端）去连接；<br>Listen： 此种模式下，是我们（调试客户端）去监听一个端口，当调试服务端准备好了，就会进行连接。</p>
</blockquote>
</blockquote>
</li>
<li>transport:<blockquote>
<blockquote>
<p>Socket：macOS 及 Linux 系统使用此种传输方式；<br>Shared memory： Windows 系统使用此种传输方式。</p>
</blockquote>
</blockquote>
</li>
<li>host: 填要调试的远程服务器ip</li>
<li>port：填要调试的远程服务器的调试端口（该端口要开放）</li>
<li>JDK环境：选运行的java对应的jdk环境</li>
<li>use module classpath:选择要调试的项目模块</li>
<li>CMD line arguments: 配置好apply后内部会生成对应的远程调试参数（黄色标记部分）<h1 id="配置Tomcat的debug模式"><a href="#配置Tomcat的debug模式" class="headerlink" title="配置Tomcat的debug模式"></a>配置Tomcat的debug模式</h1>进入$TOMCAT_HOME/bin目录下,讲CMD参数复制添加到tomcat的catalina.sh配置中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vi catalina.sh</span><br><span class="line">#在# OS specific support.上面添加</span><br><span class="line"><span class="keyword">export</span> JAVA_OPTS=<span class="string">'-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005'</span></span><br></pre></td></tr></table></figure>
<p>开启相关端口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/iptables </span><br><span class="line">#在-A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT之后添加</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">8080</span> -j ACCEPT</span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">5005</span> -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>重启防火墙</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service  iptables restart</span><br></pre></td></tr></table></figure>
<p>启动好远程的tomcat项目后，点击debug图标，打上要调试的断电就可以远程debug了。<br><img src="IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4_files/3.jpg" alt=""></p>
<img src="/2020/09/04/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4/3.jpg" class="">
<h1 id="配置SpringBoot的debug模式"><a href="#配置SpringBoot的debug模式" class="headerlink" title="配置SpringBoot的debug模式"></a>配置SpringBoot的debug模式</h1><p>在远程服务上，执行<font color="red">java -jar <code>粘贴刚刚复制的</code> app.jar </font>启动服务即可。<br>然后在IDEA用配置的debug启动，如下图说明成功。</p>
<img src="/2020/09/04/IDEA%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E6%95%99%E7%A8%8B%E6%AD%A5%E9%AA%A4/4.jpg" class="">
]]></content>
      <categories>
        <category>工具</category>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>NIO -1</title>
    <url>/2020/09/11/NIO/</url>
    <content><![CDATA[<p>本文将介绍 Java NIO 中三大组件 Buffer、Channel、Selector 的使用。</p>
<a id="more"></a>
<blockquote>
<p>文章转载自：<a href="https://javadoop.com/post/java-nio" target="_blank" rel="noopener">JavaDoop博客</a></p>
</blockquote>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>一个 Buffer 本质上是内存中的一块，我们可以将数据写入这块内存，之后从这块内存获取数据。<br>java.nio 定义了以下几个 Buffer 的实现，这个图读者应该也在不少地方见过了吧。<br><img src="NIO_files/1.jpg" alt=""></p>
<img src="/2020/09/11/NIO/1.jpg" class="">
<p>其实核心是最后的 <strong>ByteBuffer</strong>，前面的一大串类只是包装了一下它而已，我们使用最多的通常也是 ByteBuffer。</p>
<p>我们应该将 Buffer 理解为一个数组，IntBuffer、CharBuffer、DoubleBuffer 等分别对应 int[]、char[]、double[] 等。</p>
<p>MappedByteBuffer 用于实现内存映射文件，也不是本文关注的重点。</p>
<p>我觉得操作 Buffer 和操作数组、类集差不多，只不过大部分时候我们都把它放到了 NIO 的场景里面来使用而已。下面介绍 Buffer 中的几个重要属性和几个重要方法。<br><strong>position、limit、capacity</strong><br>就像数组有数组容量，每次访问元素要指定下标，Buffer 中也有几个重要属性：position、limit、capacity。<br><img src="NIO_files/2.jpg" alt=""></p>
<img src="/2020/09/11/NIO/2.jpg" class="">
<p>最好理解的当然是 capacity，它代表这个缓冲区的容量，一旦设定就不可以更改。比如 capacity 为 1024 的 IntBuffer，代表其一次可以存放 1024 个 int 类型的值。一旦 Buffer 的容量达到 capacity，需要清空 Buffer，才能重新写入值。</p>
<p>position 和 limit 是变化的，我们分别看下读和写操作下，它们是如何变化的。</p>
<p>position 的初始值是 0，每往 Buffer 中写入一个值，position 就自动加 1，代表下一次的写入位置。读操作的时候也是类似的，每读一个值，position 就自动加 1。</p>
<p>从写操作模式到读操作模式切换的时候（flip），position 都会归零，这样就可以从头开始读写了。</p>
<p>Limit：写操作模式下，limit 代表的是最大能写入的数据，这个时候 limit 等于 capacity。写结束后，切换到读模式，此时的 limit 等于 Buffer 中实际的数据大小，因为 Buffer 不一定被写满了。</p>
<p><img src="NIO_files/3.jpg" alt=""></p>
<img src="/2020/09/11/NIO/3.jpg" class="">
<h3 id="初始化Buffer"><a href="#初始化Buffer" class="headerlink" title="初始化Buffer"></a>初始化Buffer</h3><p>每个 Buffer 实现类都提供了一个静态方法 allocate(int capacity) 帮助我们快速实例化一个 Buffer。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer byteBuf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">IntBuffer intBuf = IntBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">LongBuffer longBuf = LongBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>另外，我们经常使用 wrap 方法来初始化一个 Buffer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">wrap</span><span class="params">(<span class="keyword">byte</span>[] array)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="填充buffer"><a href="#填充buffer" class="headerlink" title="填充buffer"></a>填充buffer</h3><p>各个 Buffer 类都提供了一些 put 方法用于将数据填充到 Buffer 中，如 ByteBuffer 中的几个 put 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充一个 byte 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 在指定位置填充一个 int 值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>;</span><br><span class="line"><span class="comment">// 将一个数组中的值填充进去</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span>[] src, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>上述这些方法需要自己控制 Buffer 大小，不能超过 capacity，超过会抛 java.nio.BufferOverflowException 异常。</p>
<p>对于 Buffer 来说，另一个常见的操作中就是，我们要将来自 Channel 的数据填充到 Buffer 中，在系统层面上，这个操作我们称为读操作，因为数据是从外部（文件或网络等）读到内存中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.read(buf);</span><br></pre></td></tr></table></figure>
<p>上述方法会返回从 Channel 中读入到 Buffer 的数据大小。</p>
<h3 id="提取Buffer中的值"><a href="#提取Buffer中的值" class="headerlink" title="提取Buffer中的值"></a>提取Buffer中的值</h3><p>前面介绍了写操作，每写入一个值，position 的值都需要加 1，所以 position 最后会指向最后一次写入的位置的后面一个，如果 Buffer 写满了，那么 position 等于 capacity（position 从 0 开始）。</p>
<p>如果要读 Buffer 中的值，需要切换模式，从写入模式切换到读出模式。注意，通常在说 NIO 的读操作的时候，我们说的是从 Channel 中读数据到 Buffer 中，对应的是对 Buffer 的写入操作，初学者需要理清楚这个。</p>
<p>调用 Buffer 的 <strong>flip()</strong> 方法，可以从写入模式切换到读取模式。其实这个方法也就是设置了一下 position 和 limit 值罢了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    limit = position; <span class="comment">// 将 limit 设置为实际写入的数据数量</span></span><br><span class="line">    position = <span class="number">0</span>; <span class="comment">// 重置 position 为 0</span></span><br><span class="line">    mark = -<span class="number">1</span>; <span class="comment">// mark 之后再说</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应写入操作的一系列 put 方法，读操作提供了一系列的 get 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据 position 来获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取指定位置的数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 将 Buffer 中的数据写入到数组中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ByteBuffer <span class="title">get</span><span class="params">(<span class="keyword">byte</span>[] dst)</span></span></span><br></pre></td></tr></table></figure>
<p>附一个经常使用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> String(buffer.array()).trim();</span><br></pre></td></tr></table></figure>
<p>当然了，除了将数据从 Buffer 取出来使用，更常见的操作是将我们写入的数据传输到 Channel 中，如通过 FileChannel 将数据写入到文件中，通过 SocketChannel 将数据写入网络发送到远程机器等。对应的，这种操作，我们称之为写操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = channel.write(buf);</span><br></pre></td></tr></table></figure>
<h3 id="mark-和reset"><a href="#mark-和reset" class="headerlink" title="mark()和reset()"></a>mark()和reset()</h3><p>除了 position、limit、capacity 这三个基本的属性外，还有一个常用的属性就是 mark。</p>
<p>mark 用于临时保存 position 的值，每次调用 mark() 方法都会将 mark 设值为当前的 position，便于后续需要的时候使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">mark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mark = position;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那到底什么时候用呢？考虑以下场景，我们在 position 为 5 的时候，先 mark() 一下，然后继续往下读，读到第 10 的时候，我想重新回到 position 为 5 的地方重新来一遍，那只要调一下 reset() 方法，position 就回到 5 了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = mark;</span><br><span class="line">    <span class="keyword">if</span> (m &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidMarkException();</span><br><span class="line">    position = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rewind-、clear-和compact"><a href="#rewind-、clear-和compact" class="headerlink" title="rewind() 、clear()和compact()"></a>rewind() 、clear()和compact()</h3><p><strong>rewind()</strong>：会重置 position 为 0，通常用于重新从头读写 Buffer。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>clear()</strong>：有点重置 Buffer 的意思，相当于重新实例化了一样。</p>
<p>通常，我们会先填充 Buffer，然后从 Buffer 读取数据，之后我们再重新往里填充新的数据，我们一般在重新填充之前先调用 clear()。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    position = <span class="number">0</span>;</span><br><span class="line">    limit = capacity;</span><br><span class="line">    mark = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>compact()</strong>：和 clear() 一样的是，它们都是在准备往 Buffer 填充新的数据之前调用。</p>
<p>前面说的 clear() 方法会重置几个属性，但是我们要看到，clear() 方法并不会将 Buffer 中的数据清空，只不过后续的写入会覆盖掉原来的数据，也就相当于清空了数据了。</p>
<p>而 compact() 方法有点不一样，调用这个方法以后，会先处理还没有读取的数据，也就是 position 到 limit 之间的数据（还没有读过的数据），先将这些数据移到左边，然后在这个基础上再开始写入。很明显，此时 limit 还是等于 capacity，position 指向原来数据的右边。</p>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>所有的 NIO 操作始于通道，通道是数据来源或数据写入的目的地，主要地，我们将关心 java.nio 包中实现的以下几个 Channel：<br><img src="NIO_files/4.jpg" alt=""></p>
<img src="/2020/09/11/NIO/4.jpg" class="">
<ul>
<li>FileChannel：文件通道，用于文件的读和写</li>
<li>DatagramChannel：用于 UDP 连接的接收和发送</li>
<li>SocketChannel：把它理解为 TCP 连接通道，简单理解就是 TCP 客户端</li>
<li>ServerSocketChannel：TCP 对应的服务端，用于监听某个端口进来的请求</li>
</ul>
<p><strong>这里不是很理解这些也没关系，后面介绍了代码之后就清晰了。还有，我们最应该关注，也是后面将会重点介绍的是 SocketChannel 和 ServerSocketChannel。</strong><br>Channel 经常翻译为通道，类似 IO 中的流，用于读取和写入。它与前面介绍的 Buffer 打交道，读操作的时候将 Channel 中的数据填充到 Buffer 中，而写操作时将 Buffer 中的数据写入到 Channel 中。</p>
<p>channel.read(buffer)和channel.write(buffer)这两个方法都是以内存（buffer所在区域）为角度，就好区分理解读写是指buffer和channel之前谁往谁读写了。</p>
<h3 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h3><p>我想文件操作对于大家来说应该是最熟悉的，不过我们在说 NIO 的时候，其实 FileChannel 并不是关注的重点。而且后面我们说非阻塞的时候会看到，FileChannel 是不支持非阻塞的。</p>
<p>这里算是简单介绍下常用的操作吧，感兴趣的读者瞄一眼就是了。</p>
<p>初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"/data.txt"</span>));</span><br><span class="line">FileChannel fileChannel = inputStream.getChannel();</span><br></pre></td></tr></table></figure>
<p>当然了，我们也可以从 RandomAccessFile#getChannel 来得到 FileChannel。</p>
<p>读取文件内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = fileChannel.read(buffer);</span><br></pre></td></tr></table></figure>
<p>前面我们也说了，所有的 Channel 都是和 Buffer 打交道的。<br>写入文件内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">buffer.put(<span class="string">"随机写入一些内容到 Buffer 中"</span>.getBytes());</span><br><span class="line"><span class="comment">// Buffer 切换为读模式</span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    <span class="comment">// 将 Buffer 中的内容写入文件</span></span><br><span class="line">    fileChannel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h3><p>我们前面说了，我们可以将 SocketChannel 理解成一个 TCP 客户端。虽然这么理解有点狭隘，因为我们在介绍 ServerSocketChannel 的时候会看到另一种使用方式。</p>
<p>打开一个 TCP 连接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(<span class="string">"https://www.wangts.site"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>
<p>当然了，上面的这行代码等价于下面的两行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开一个通道</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"https://www.javadoop.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>
<p>SocketChannel 的读写和 FileChannel 没什么区别，就是操作缓冲区。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">socketChannel.read(buffer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入数据到网络连接中</span></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    socketChannel.write(buffer);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h3><p>之前说 SocketChannel 是 TCP 客户端，这里说的 ServerSocketChannel 就是对应的服务端。</p>
<p>ServerSocketChannel 用于监听机器端口，管理从这个端口进来的 TCP 连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"><span class="comment">// 监听 8080 端口</span></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 一旦有一个 TCP 连接进来，就对应创建一个 SocketChannel 进行处理</span></span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们可以看到 SocketChannel 的第二个实例化方式<br>到这里，我们应该能理解 SocketChannel 了，它不仅仅是 TCP 客户端，它代表的是一个网络通道，可读可写。</p>
</blockquote>
<p>ServerSocketChannel 不和 Buffer 打交道了，因为它并不实际处理数据，它一旦接收到请求后，实例化 SocketChannel，之后在这个连接通道上的数据传递它就不管了，因为它需要继续监听端口，等待下一个连接。</p>
<h3 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h3><p>UDP 和 TCP 不一样，DatagramChannel 一个类处理了服务端和客户端。</p>
<blockquote>
<p>科普一下，UDP 是面向无连接的，不需要和对方握手，不需要通知对方，就可以直接将数据包投出去，至于能不能送达，它是不知道的<br><strong>监听端口</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9090</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure>
<p><strong>发送数据</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span></span><br><span class="line">                    + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>NIO 三大组件就剩 Selector 了，Selector 建立在非阻塞的基础之上，大家经常听到的 多路复用 在 Java 世界中指的就是它，用于实现一个线程管理多个 Channel。</p>
<p>读者在这一节不能消化 Selector 也没关系，因为后续在介绍非阻塞 IO 的时候还得说到这个，这里先介绍一些基本的接口操作。</p>
<ul>
<li><p>首先，我们开启一个 Selector。你们爱翻译成选择器也好，多路复用器也好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></li>
<li><p>将 Channel 注册到 Selector 上。前面我们说了，Selector 建立在非阻塞模式之上，所以注册到 Selector 的 Channel 必须要支持非阻塞模式，<strong>FileChannel</strong> 不支持非阻塞，我们这里讨论最常见的 SocketChannel 和 ServerSocketChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将通道设置为非阻塞模式，因为默认都是阻塞模式的</span></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 注册</span></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<p>register 方法的第二个 int 型参数（使用二进制的标记位）用于表明需要监听哪些感兴趣的事件，共以下四种事件：</p>
</li>
<li><p>SelectionKey.OP_READ</p>
</li>
</ul>
<blockquote>
<p>对应 00000001，通道中有数据可以进行读取</p>
</blockquote>
<ul>
<li>SelectionKey.OP_WRITE</li>
</ul>
<blockquote>
<p>对应 00000100，可以往通道中写入数据</p>
</blockquote>
<ul>
<li>SelectionKey.OP_CONNECT</li>
</ul>
<blockquote>
<p>对应 00001000，成功建立 TCP 连接</p>
</blockquote>
<ul>
<li>SelectionKey.OP_ACCEPT</li>
</ul>
<blockquote>
<p>对应 00010000，接受 TCP 连接<br>我们可以同时监听一个 Channel 中的发生的多个事件，比如我们要监听 ACCEPT 和 READ 事件，那么指定参数为二进制的 00010001 即十进制数值 17 即可。</p>
</blockquote>
<p>注册方法返回值是 SelectionKey 实例，它包含了 Channel 和 Selector 信息，也包括了一个叫做 Interest Set 的信息，即我们设置的我们感兴趣的正在监听的事件集合。</p>
<ul>
<li>调用 select() 方法获取通道信息。用于判断是否有我们感兴趣的事件已经发生了。</li>
</ul>
<p>Selector 的操作就是以上 3 步，这里来一个简单的示例，大家看一下就好了。之后在介绍非阻塞 IO 的时候，会演示一份可执行的示例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是否有事件准备好</span></span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历</span></span><br><span class="line">  Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Selector，我们还需要非常熟悉以下几个方法：</p>
<p><strong>select()</strong></p>
<p>调用此方法，会将上次 select 之后的准备好的 channel 对应的 SelectionKey 复制到 selected set 中。如果没有任何通道准备好，这个方法会阻塞，直到至少有一个通道准备好。</p>
<p><strong>selectNow()</strong></p>
<p>功能和 select 一样，区别在于如果没有准备好的通道，那么此方法会立即返回 0。</p>
<p><strong>select(long timeout)</strong></p>
<p>看了前面两个，这个应该很好理解了，如果没有通道准备好，此方法会等待一会</p>
<p><strong>wakeup()</strong></p>
<p>这个方法是用来唤醒等待在 select() 和 select(timeout) 上的线程的。如果 wakeup() 先被调用，此时没有线程在 select 上阻塞，那么之后的一个 select() 或 select(timeout) 会立即返回，而不会阻塞，当然，它只会作用一次。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到此为止，介绍了 Buffer、Channel 和 Selector 的常见接口。</p>
<p>Buffer 和数组差不多，它有 position、limit、capacity 几个重要属性。put() 一下数据、flip() 切换到读模式、然后用 get() 获取数据、clear() 一下清空数据、重新回到 put() 写入数据。</p>
<p>Channel 基本上只和 Buffer 打交道，最重要的接口就是 channel.read(buffer) 和 channel.write(buffer)。</p>
<p>Selector 用于实现非阻塞 IO，这里仅仅介绍接口使用，后续请关注非阻塞 IO 的介绍。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title>LVM逻辑卷、卷组基本操作</title>
    <url>/2020/10/13/LVM%E9%80%BB%E8%BE%91%E5%8D%B7%E3%80%81%E5%8D%B7%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>LVM逻辑卷、卷组基本操作增删扩缩</p>
<a id="more"></a>
<p>LVM逻辑卷管理<br>LVM逻辑卷管理(Logical Volume Manager),是建立在物理存储设备上的一个抽象层，允许生成逻辑存储卷，与直接使用物理存储在管理上相比，提供了更好的灵活性。</p>
<p>LVM将存储虚拟化，使用逻辑卷，不会受限于物理磁盘的大小，另外，与硬件相关的存储设置被隐藏，可以不用停止应用或卸载文件系统来调整卷大小或数据迁移，这样可以减少操作成本。</p>
<h1 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h1><ul>
<li><p>物理卷–PV(Physical Volume)<br>物理卷在逻辑卷管理中处于最底层，它可以是实际物理磁盘上的分区，也可以是整个物理硬盘。</p>
</li>
<li><p>卷组–VG(Volume Group)<br>卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。</p>
</li>
<li><p>逻辑卷–LV(Logical Volume)<br>逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组。</p>
</li>
<li><p>物理区域–PE（Physical Extent）<br>物理区域是物理卷中可用于分配的最小存储单元，物理区域的大小可根据实际情况在建立物理卷时指定。物理区域大小一旦确定将不能更改，同一卷组中的所有物理卷的物理区域大小需要一致。</p>
</li>
<li><p>逻辑区域—LE（Logical Extent）<br>逻辑区域是逻辑卷中可用于分配的最小存储单元，逻辑区域的大小取决于逻辑卷所在卷组中的物理区域的大小。</p>
</li>
<li><p>卷组描述区域（Volume Group Descriptor Area）<br>卷组描述区域存在于每个物理卷中，用于描述物理卷本身、物理卷所属卷组、卷组中的逻辑卷及逻辑卷中物理区域的分配等所有信息，卷组描述区域是在使用pvcreate建立物理卷时建立的。</p>
</li>
</ul>
<h2 id="创建LVM"><a href="#创建LVM" class="headerlink" title="创建LVM"></a>创建LVM</h2><ol>
<li><p>将物理磁盘设备初始化为物理卷</p>
<blockquote>
<p>pvcreate /dev/sdb /dev/sdc</p>
</blockquote>
</li>
<li><p>创建卷组，并将PV加入卷组中</p>
<blockquote>
<p>vgcreat linuxvg /dev/sdb /dev/sdc</p>
</blockquote>
</li>
<li><p>基于卷组创建逻辑卷</p>
<blockquote>
<p>lvcreat -n linuxlv -L 2G linuxvg</p>
</blockquote>
</li>
<li><p>为创建好的逻辑卷创建文件系统</p>
<blockquote>
<p>mkfs.ext4 /dev/linuxvg/linuxlv</p>
</blockquote>
</li>
<li><p>将格式化好的逻辑卷挂载使用</p>
<blockquote>
<p>mount /dev/linuxvg/linuxlv /mnt</p>
</blockquote>
</li>
</ol>
<h2 id="查看LVM"><a href="#查看LVM" class="headerlink" title="查看LVM"></a>查看LVM</h2><ol>
<li><p>查看物理卷信息</p>
<blockquote>
<p>pvdisplay（详细）<br>pvs</p>
</blockquote>
</li>
<li><p>查看卷组信息</p>
<blockquote>
<p>vgdisplay（详细）<br>vgs</p>
</blockquote>
</li>
<li><p>查看逻辑卷信息</p>
<blockquote>
<p>lvdisplay（详细）<br>lvs</p>
</blockquote>
</li>
</ol>
<h2 id="删除逻辑卷"><a href="#删除逻辑卷" class="headerlink" title="删除逻辑卷"></a>删除逻辑卷</h2><ol>
<li><p>首先删除一个逻辑卷</p>
<blockquote>
<p>lvremove /dev/linuxvg/linuxlv</p>
</blockquote>
</li>
<li><p>删除一个卷组</p>
<blockquote>
<p>vgremove linuxvg</p>
</blockquote>
</li>
<li><p>删除物理卷</p>
<blockquote>
<p>pvremove /dev/sdb</p>
</blockquote>
</li>
</ol>
<h2 id="LVM-拉伸与缩小"><a href="#LVM-拉伸与缩小" class="headerlink" title="LVM 拉伸与缩小"></a>LVM 拉伸与缩小</h2><ol>
<li><p>拉伸一个逻辑卷，保证VG有足够的空闲空间</p>
<blockquote>
<p>vgdisplay</p>
</blockquote>
</li>
<li><p>扩充逻辑卷</p>
<blockquote>
<p>lvextend -L +1G /dev/linuxvg/linuxlv</p>
</blockquote>
</li>
<li><p>查看扩充后LV大小</p>
<blockquote>
<p>lvdisplay</p>
</blockquote>
</li>
<li><p>更新文件系统</p>
<blockquote>
<p>resize2fs /dev/linuxvg/linuxlv</p>
</blockquote>
</li>
<li><p>查看更新后文件系统</p>
<blockquote>
<p>df -h</p>
</blockquote>
</li>
</ol>
<h2 id="拉伸一个卷组"><a href="#拉伸一个卷组" class="headerlink" title="拉伸一个卷组"></a>拉伸一个卷组</h2><ol>
<li><p>将要添加到VG的硬盘“格式化”为PV</p>
<blockquote>
<p>pvcreate /dev/sdd</p>
</blockquote>
</li>
<li><p>将新的PV添加到指定卷组中</p>
<blockquote>
<p>vgextend linuxvg /dev/sdd</p>
</blockquote>
</li>
<li><p>查看扩充后VG大小</p>
<blockquote>
<p>vgdisplay</p>
</blockquote>
</li>
</ol>
<h2 id="缩小一个逻辑卷"><a href="#缩小一个逻辑卷" class="headerlink" title="缩小一个逻辑卷"></a>缩小一个逻辑卷</h2><ol>
<li><p>卸载已经挂在的逻辑卷</p>
<blockquote>
<p>umount /dev/linuxvg/linuxlv</p>
</blockquote>
</li>
<li><p>缩小文件系统（会提示需要运行fsck检查文件系统）</p>
<blockquote>
<p>resize2fs /dev/linuxvg/linuxlv 1G(调整大小为1G)</p>
</blockquote>
</li>
<li><p>缩小LV</p>
<blockquote>
<p>lvreduce -L 1G /dev/linuxvg/linuxlv</p>
</blockquote>
</li>
<li><p>查看缩小后的LV</p>
<blockquote>
<p>lvdisplay</p>
</blockquote>
</li>
<li><p>挂载</p>
<blockquote>
<p>mount /dev/linuxvg/linuxlv /mnt</p>
</blockquote>
</li>
</ol>
<h2 id="缩小卷组"><a href="#缩小卷组" class="headerlink" title="缩小卷组"></a>缩小卷组</h2><ol>
<li><p>将一个PV从卷组中移除</p>
<blockquote>
<p>vgreduce linuxvg /dev/sdc</p>
</blockquote>
</li>
<li><p>查看缩小后的卷组大小</p>
<blockquote>
<p>vgdisplay</p>
</blockquote>
</li>
</ol>
<h2 id="逻辑卷重新分配磁盘空间"><a href="#逻辑卷重新分配磁盘空间" class="headerlink" title="逻辑卷重新分配磁盘空间"></a>逻辑卷重新分配磁盘空间</h2><p><a href="https://blog.csdn.net/llwy1428/article/details/86467598" target="_blank" rel="noopener">记一次 Centos系统/home的部分磁盘空间重新挂载给/root</a></p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>运维</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>fastDFS文件存储定时删除历史文件</title>
    <url>/2020/11/18/fastDFS%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4%E5%8E%86%E5%8F%B2%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>xshell连接fastDFS文件存储服务器</p>
<blockquote>
<p>删除存储路径下的所有超过N天的文件</p>
</blockquote>
</blockquote>
<a id="more"></a>
<hr>
<ol>
<li>在/opt目录下创建scripts<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;opt&#x2F;scripts</span><br></pre></td></tr></table></figure></li>
<li>创建fdfs_auto_delete.sh<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;scripts</span><br><span class="line">touch fdfs_auto_delete.sh</span><br></pre></td></tr></table></figure></li>
<li>对fdfs_auto_delete.sh授权<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod -R 777 fdfs_auto_delete.sh</span><br></pre></td></tr></table></figure></li>
<li>修改fdfs-startup.sh文件<br>添加文件内容如下图所示：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">#删除存储路径下的所有超过30天的文件</span><br><span class="line"># *.* 如果只删jpg图片,修改成*.jpg</span><br><span class="line">find /opt/fastdfs_storage_data/data/ -mtime +<span class="number">30</span> -name <span class="string">"*.*"</span> -exec rm -rf &#123;&#125; \;</span><br></pre></td></tr></table></figure></li>
<li>设置linux定时任务<br>使用crontab命令添加定时任务<br>#打开定时任务配置文件<br>crontab -e<br>添加如下定时器任务<br>#添加如下内容（每天凌晨1点执行历史文件存储删除）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># m       h       dom    mon  dow    command</span><br><span class="line"># 分钟    小时     某天    某月  星期几  命令</span><br><span class="line">0 1 * * *  &#x2F;opt&#x2F;scripts&#x2F;fdfs_auto_delete.sh</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
        <category>Linux</category>
        <category>运维</category>
        <category>fastDFS</category>
      </categories>
      <tags>
        <tag>文件存储服务</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7离线一键安装fastDfs</title>
    <url>/2020/12/03/CentOS7%E7%A6%BB%E7%BA%BF%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85fastDfs/</url>
    <content><![CDATA[<blockquote>
<p>一键安装所有相关依赖，无需联网，比在线安装更简单！</p>
<blockquote>
<p>本离线版已配置服务自启动</p>
</blockquote>
</blockquote>
<a id="more"></a>

<ul>
<li>fastDfs版本5.11</li>
<li>默认文件服务存储数据安装在/home下，如需修改，请修改autorun.sh内对应位置</li>
<li><a href="链接：https://pan.baidu.com/s/1c8J5Yld0FJCYk2qWiTccfw">离线包下载地址</a><br>提取码：wang<br><img src="CentOS7%E7%A6%BB%E7%BA%BF%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85fastDfs_files/1.png" alt=""><img src="/2020/12/03/CentOS7%E7%A6%BB%E7%BA%BF%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85fastDfs/1.png" class="">

</li>
</ul>
<p>操作步骤：</p>
<ol>
<li>将解压后的文件夹复制到/opt目录下</li>
<li>赋予一键执行脚本可执行权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;opt&#x2F;fastdfs</span><br><span class="line">chmod +x autorun.sh</span><br></pre></td></tr></table></figure></li>
<li>执行安装 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;autorun.sh</span><br></pre></td></tr></table></figure></li>
<li>输入本服务器的ip地址，回车。</li>
</ol>
<p>观察终端输出，没有报错的话最后会生成测试图片url，复制后在浏览器访问成功即可。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Linux</category>
        <category>运维</category>
        <category>fastDFS</category>
      </categories>
  </entry>
</search>
